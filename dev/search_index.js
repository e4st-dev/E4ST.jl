var documenterSearchIndex = {"docs":
[{"location":"types/policy/#Policy","page":"Policy","title":"Policy","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"Policy","category":"page"},{"location":"types/policy/#E4ST.Policy","page":"Policy","title":"E4ST.Policy","text":"abstract type Policy <: Modification\n\nThis is a subtype of Modification that represents a policy to be modeled.\n\nBasic Policy Types are used when defining standard policies in E4ST. They are specified as mods in the config file with a type field. \n\nThere are currently six basic policy types. Novel policy types can also be added as needed. \n\nPolicies (Policy subtypes)\n\nITC\nPTC\nEmissionCap\nEmissionPrice\nRPS\nCES\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#Tax-Credits","page":"Policy","title":"Tax Credits","text":"","category":"section"},{"location":"types/policy/#ITC","page":"Policy","title":"ITC","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"ITC\nmodify_setup_data!(pol::ITC, config, data)\nmodify_model!(pol::ITC, config, data, model)","category":"page"},{"location":"types/policy/#E4ST.ITC","page":"Policy","title":"E4ST.ITC","text":"struct ITC <: Policy\n\nInvestment Tax Credit - A tax incentive that is a percentage of capital cost given to generators that meet the qualifications. \n\nKeyword Arguments\n\nname: policy name\nvalues: the credit level, stored as an OrderedDict with year and value (:y2020=>0.3).  Credit level refers to the percentage of the capex that will be rebated to the investor\ngen_filters: filters for qualifying generators, stored as an OrderedDict with gen table columns and values (:emis_co2=>\"<=0.1\" for co2 emission rate less than or equal to 0.1)\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.modify_setup_data!-Tuple{ITC, Any, Any}","page":"Policy","title":"E4ST.modify_setup_data!","text":"E4ST.modify_setup_data!(pol::ITC, config, data)\n\nCreates a column in the gen table with the ITC value in each simulation year for the qualifying generators.\n\nITC values are calculated based on capex_obj so ITC values only apply in year_on for a generator.\n\n\n\n\n\n","category":"method"},{"location":"types/policy/#E4ST.modify_model!-Tuple{ITC, Any, Any, Any}","page":"Policy","title":"E4ST.modify_model!","text":"function E4ST.modify_model!(pol::ITC, config, data, model)\n\nSubtracts the ITC price * Capacity in that year from the objective function using add_obj_term!(data, model, PerMWCap(), pol.name, oper = -)\n\n\n\n\n\n","category":"method"},{"location":"types/policy/#PTC","page":"Policy","title":"PTC","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"PTC\nmodify_setup_data!(pol::PTC, config, data)\nmodify_model!(pol::PTC, config, data, model)","category":"page"},{"location":"types/policy/#E4ST.PTC","page":"Policy","title":"E4ST.PTC","text":"struct PTC <: Policy\n\nProduction Tax Credit - A $/MWh tax incentive for the generation of specific technology or under specific conditions.\n\nKeyword Arguments\n\nname: policy name \nvalues: $/MWh values of the PTC, stored as an OrderedDict with years and the value (:y2020=>10), note year is a Symbol\nyears_after_ref_min: Min (inclusive) number of years the sim year can be after gen reference year (ie. yearon, yearretrofit). If ref year is year_on then this would be equivaled to min gen age. \nyears_after_ref_max: Max (inclusive) number of years the sim year can be after gen reference year (ie. yearon, yearretrofit). If ref year is year_on then this would be equivaled to max gen age.\nref_year_col: Column name to use as reference year for min and max above. Must be a year column. If this is :yearon, then the yearsafterref filters will filter gen age. If this is :yearretrofit, the the yearsafterref filters will filter by time since retrofit. \ngen_filters: filters for qualifying generators, stored as an OrderedDict with gen table columns and values (:emis_co2=>\"<=0.1\" for co2 emission rate less than or equal to 0.1)\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.modify_setup_data!-Tuple{PTC, Any, Any}","page":"Policy","title":"E4ST.modify_setup_data!","text":"E4ST.modify_setup_data!(pol::PTC, config, data)\n\nCreates a column in the gen table with the PTC value in each simulation year for the qualifying generators.\n\n\n\n\n\n","category":"method"},{"location":"types/policy/#E4ST.modify_model!-Tuple{PTC, Any, Any, Any}","page":"Policy","title":"E4ST.modify_model!","text":"function E4ST.modify_model!(pol::PTC, config, data, model)\n\nSubtracts the PTC price * generation in that year from the objective function using add_obj_term!(data, model, PerMWhGen(), pol.name, oper = -)\n\n\n\n\n\n","category":"method"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"Derivation of the PTC capex adjustment First, find the adjusted PTC value x if it were a constant cash flow over entire econ lifetime l. \nStart by setting the NPV of the actual PTC (per MW capacity) p and the adjusted PTC (per MW capacity) x. \nm is the minimum age of the generator to qualify for the PTC \nn is the maximum age of the generator to qualify for the PTC ","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"sum_i=1^l x  left(1+r right)^i = sum_i=m^n p  left(1+r right)^i","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"$","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"x \\left( \\frac{1- \\left(\\frac{1}{1+r}\\right)^l}{1 - \\left(\\frac{1}{1+r}\\right)}\\right) = p \\left( \\frac{1- \\left(\\frac{1}{1+r}\\right)^n}{1 - \\left(\\frac{1}{1+r}\\right)^{m+1}}\\right) $","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"$","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"x = p \\frac{\\left(1- \\left(\\frac{1}{1+r}\\right)^n\\right)\\left(1 - \\left(\\frac{1}{1+r}\\right)\\right)}{\\left(1- \\left(\\frac{1}{1+r}\\right)^l\\right)\\left(1 - \\left(\\frac{1}{1+r}\\right)^{m+1}\\right)} $","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"To get the adjustement to capex capex_ adj we can start with  $ capex + capex_ adj + p = capex + x $  so $ capex_ adj = p - x $","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"$","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"capex_ adj = p \\left(1 - \\left(\\frac{\\left(1- \\left(\\frac{1}{1+r}\\right)^n\\right)\\left(1 - \\left(\\frac{1}{1+r}\\right)\\right)}{\\left(1- \\left(\\frac{1}{1+r}\\right)^l\\right)\\left(1 - \\left(\\frac{1}{1+r}\\right)^{m+1}\\right)}\\right)\\right) $","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"The value of the PTC per MW capacity p is equal to the PTC in per MWh terms PTC * capacity factor cf. We can substitute this in to get the final formula","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"$","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"capex_ adjust = PTC*cf\\left(1 - \\left(\\frac{\\left(1- \\left(\\frac{1}{1+r}\\right)^n\\right)\\left(1 - \\left(\\frac{1}{1+r}\\right)\\right)}{\\left(1- \\left(\\frac{1}{1+r}\\right)^l\\right)\\left(1 - \\left(\\frac{1}{1+r}\\right)^{m+1}\\right)}\\right)\\right) $","category":"page"},{"location":"types/policy/#GenerationStandard","page":"Policy","title":"GenerationStandard","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"GenerationStandard is a type used for policies that give some generators certain credits and constrain generation to a certain target. The primary examples are CESs, RPSs, and state carveouts. ","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"GenerationStandard\nmodify_setup_data!(pol::GenerationStandard, config, data)\nmodify_model!(pol::GenerationStandard, config, data, model)","category":"page"},{"location":"types/policy/#E4ST.GenerationStandard","page":"Policy","title":"E4ST.GenerationStandard","text":"struct GenerationStandard{T} <: Policy\n\nA generation standard (also refered to as a portfolio standard) is a constraint on generation where a portion of generation from certain generators must meet the a portion of the load in a specified region. This encompasses RPSs, CESs, and technology carveouts. To assign the credit (the portion of generation that can contribute) to generators, the Crediting type is used.\n\nname - Name of the policy \ngen_filters - Filters on which generation qualifies to fulfill the GS. Sometimes qualifying generators may be outside of the GS load region if they supply power to it. \ncrediting - the crediting structure and related fields\nload_targets - OrderedDict containing key-value pairs where each key is the name of a requirement (not currently used), and each value is an OrderedDict with the following keys:\nfilters - Filters on which buses fall into the GS load region. The GS will be applied to the load from these buses. \ntargets - The yearly percent targets of the qualifying load that must be covered by the qualifying generation.\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.modify_setup_data!-Tuple{GenerationStandard, Any, Any}","page":"Policy","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(pol::GenerationStandard, config, data)\n\nAdds column to the gen table with the credit level of the generation standard. Adds the name and type of the policy to the gspollist in data. \n\n\n\n\n\n","category":"method"},{"location":"types/policy/#E4ST.modify_model!-Tuple{GenerationStandard, Any, Any, Any}","page":"Policy","title":"E4ST.modify_model!","text":"modify_model!(pol::GenerationStandard, config, data, model)\n\nCreates the expression :pgsbus, the load that generation standards are applied to, if it hasn't been created already.  Creates a constraint that takes the general form: sum(gs_egen * credit) <= gs_value * sum(gs_load)\n\n\n\n\n\n","category":"method"},{"location":"types/policy/#Crediting","page":"Policy","title":"Crediting","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"Crediting\nget_credit\nStandardRPSCrediting\nCreditByGentype\nCreditByBenchmark\nAvailabilityFactorCrediting\nStandardStorageReserveCrediting","category":"page"},{"location":"types/policy/#E4ST.Crediting","page":"Policy","title":"E4ST.Crediting","text":"abstract type Crediting\n\nCrediting is used to set the credit levels of generators for policies. It is primarily used for GenerationStandards and ReserveRequirements (RPS, CES, carveouts, etc). \n\nSetup inside config yaml\n\nCrediting is specified in the yaml file. A type key must be specified, along with the approriate keys for the credit type you specified. Two examples are shown in the config below.\n\nbase_out_path:    \"../out/3bus_rps\"\nmods:\n  example_rps:\n    type: \"RPS\"\n    crediting: \n      type: \"StandardRPSCrediting\"\n    gen_filters:\n      nation: \"archenland\"\n    load_targets:\n      stormness_rps:\n        filters:\n          state: stormness\n        targets:\n          y2035: 0.9\n          y2040: 0.95\n  example_rps_gentype:\n    type: \"RPS\"\n    crediting: \n      type: \"CreditByGentype\"\n      credits:\n        solar: 0.8\n        wind: 1.0\n        oswind: 1.0\n    gen_filters:\n      nation: \"narnia\"\n    load_targets:\n      narnia_rps:\n        targets:\n          y2030: 0.7\n          y2035: 0.8\n          y2040: 0.9\n        filters:  \n          nation: \"narnia\"\n  stor:\n    type: Storage\n    file: \"../data/3bus/storage.csv\"\n\n\n\nStandard Crediting subtypes include:\n\nCreditByBenchmark\nCreditByGentype\n\nInterfaces Implements\n\nget_credit(c::Crediting, data, gen_row::DataFrameRow) - gets the appropriate credit level for the generator row for the given Crediting subtype.\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.get_credit","page":"Policy","title":"E4ST.get_credit","text":"get_credit(c::Crediting, data, gen_row::DataFrame) ->\n\nReturn the credit value for the given generator and crediting type. \n\n\n\n\n\nget_credit(c::CreditByGentype, data, gen_row::DataFrameRow)\n\nReturns the credit level specified for the gentype in c.credits. If no credit is specified for that gentype, it defaults to 0. \n\n\n\n\n\nget_credit(c::CreditByBenchmark, data, gen_row::DataFrameRow) ->\n\nReturns the credit level based on the formula max(1.0 - (gen_row[gen_col] / c.benchmark), 0.0). \n\n\n\n\n\n","category":"function"},{"location":"types/policy/#E4ST.StandardRPSCrediting","page":"Policy","title":"E4ST.StandardRPSCrediting","text":"struct StandardRPSCrediting <: Crediting\n\nStandard RPS crediting structure. Anything included in the RPS gentypes recieves a credit of 1.  Creates a CreditByGentype\n\n[\"solar\", \"dist_solar\", \"wind\", \"oswind\", \"geothermal\", \"hcc_new\", \"hcc_ret\"]\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.CreditByGentype","page":"Policy","title":"E4ST.CreditByGentype","text":"CreditByGentype(;credits::OrderedDict{String, Float64})\n\nCrediting method where credit levels are specified by gentypes. \n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.CreditByBenchmark","page":"Policy","title":"E4ST.CreditByBenchmark","text":"CreditByBenchmark(;gen_col, benchmark)\n\nAwards credit of each generator based on how that generator's gen_col compares to benchmark, using the following formula.\n\nmax(1.0 - (gen_row[gen_col] / benchmark), 0.0)\n\ngen_col::Symbol - the column of the gen table to compare against\nbenchmark::Float64 - the benchmark rate to compare with, in the same units as the gen_col.\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.AvailabilityFactorCrediting","page":"Policy","title":"E4ST.AvailabilityFactorCrediting","text":"AvailabilityFactorCrediting <: Crediting\n\nReturns the availability factor of the generator.\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.StandardStorageReserveCrediting","page":"Policy","title":"E4ST.StandardStorageReserveCrediting","text":"struct StandardStorageReserveCrediting <: Crediting\n\nAwards crediting to storage facilities based on their discharge duration and capacity.  The values were retrieved from NYISO at the following website:\n\nhttps://www.nyiso.com/documents/20142/23590734/20210805%20NYISO%20-%20Capacity%20Accreditation%20Current%20Rules%20Final.pdf\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#CES","page":"Policy","title":"CES","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"CES is an alias for GenerationStandard. Modifying functions called on a CES will use the GenerationStandard method. ","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"CES","category":"page"},{"location":"types/policy/#E4ST.CES","page":"Policy","title":"E4ST.CES","text":"const CES = GenerationStandard{:CES}\n\nClean Energy Standard - A policy in which the load serving entity must purchase a certain ampount of clean energy credits.  The number of credits for a type of generation typically depends on it's emission rates relative to a benchmark.\n\nCES is defined as an alias of GenerationStandard. \n\nNo default crediting is specified although the standard crediting will be CreditByBenchmark where the benchmark should be specified in the config.\n\nFields\n\nname - Name of the policy \ntargets - The yearly targets for the CES\ncrediting - the crediting structure and related fields. CES crediting is often CreditByBenchmark. \ngen_filters - Filters on which generation qualifies to fulfill the CES. Sometimes qualifying generators may be outside of the RPS load region if they supply power to it. \nload_bus_filters - Filters on which buses fall into the load region. The CES will be applied to the load from these buses. \n\nGenerationStandard\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#RPS","page":"Policy","title":"RPS","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"RPS is an alias for GenerationStandard. Modifying functions called on an RPS will use the GenerationStandard method.","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"RPS","category":"page"},{"location":"types/policy/#E4ST.RPS","page":"Policy","title":"E4ST.RPS","text":"const RPS = GenerationStandard{:RPS}\n\nRenewable Portfolio Standard - A policy that constrains a certain amount of load from a region to be supplied by qualifying clean/renewable energy. \n\nRPS is defined as an alias of GenerationStandard where the default crediting type is StandardRPSCrediting. mod_rank for RPS will be 1.0 because that is the rank of GenerationStandards\n\nFields\n\nname - Name of the policy \ntargets - The yearly targets for the RPS\ncrediting - the crediting structure and related fields. Standard CES crediting is CreditingByBenchmark.\ngen_filters - Filters on which generation qualifies to fulfill the RPS. Sometimes qualifying generators may be outside of the RPS load region if they supply power to it.  \nload_bus_filters - Filters on which buses fall into the RPS load region. The RPS will be applied to the load from these buses. \n\nGenerationStandard\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#GenerationConstraint","page":"Policy","title":"GenerationConstraint","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"GenerationConstraint is a type used for constraining generation from some generators to a certain max or min amount. The max and min can also be defined in terms of another column in the gen table such as emissions. A GenerationConstraint is defined when creating an EmissionCap but can be used for more general modifications beyond policies as well. ","category":"page"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"GenerationConstraint\nmodify_model!(cons::GenerationConstraint, config, data, model)","category":"page"},{"location":"types/policy/#E4ST.GenerationConstraint","page":"Policy","title":"E4ST.GenerationConstraint","text":"struct GenerationConstraint <: Modification\n\nGeneration Constraint - A Modification that applies a constraint based on (yearly generation) * (a column from the gen table). \n\nname: modification name \ncol: gen table column\nmax_values: maximum values for a year (defaults as an empty OrderedDict if no maxs)\nmin_values: minimum values for a year (defaults as an empty OrderedDict if no mins)\ngen_filters: OrderedDict of the generator filters\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.modify_model!-Tuple{GenerationConstraint, Any, Any, Any}","page":"Policy","title":"E4ST.modify_model!","text":"modify_model!(cons::GenerationConstraint, config, data, model)\n\nCreates upper and lower bound constraints on the generators.  See also GenerationConstraint for more details\n\n\n\n\n\n","category":"method"},{"location":"types/policy/#EmissionCap","page":"Policy","title":"EmissionCap","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"EmissionCap\nmodify_model!(pol::EmissionCap, config, data, model)","category":"page"},{"location":"types/policy/#E4ST.EmissionCap","page":"Policy","title":"E4ST.EmissionCap","text":"struct EmissionCap <: Policy\n\nEmission Cap - A limit on a certain emission for a given set of generators.\n\nname: name of the policy (Symbol)\nemis_col: name of the emission rate column in the gen table (ie. emis_co2) (Symbol)\ntargets: OrderedDict of cap targets by year\ngen_filters: OrderedDict of generator filters\ngen_cons: GenerationConstraint Modification created on instantiation of the EmissionCap (not specified in config). It sets the cap targets as the max_targets of the GenerationConstraint and passes on other fields.\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.modify_model!-Tuple{EmissionCap, Any, Any, Any}","page":"Policy","title":"E4ST.modify_model!","text":"E4ST.modify_model!(pol::EmissionCap, config, data, model)\n\nCalls modify_model!(cons::GenerationConstraint, config, data, model)\n\n\n\n\n\n","category":"method"},{"location":"types/policy/#EmissionPrice","page":"Policy","title":"EmissionPrice","text":"","category":"section"},{"location":"types/policy/","page":"Policy","title":"Policy","text":"EmissionPrice\nmodify_model!(pol::EmissionPrice, config, data, model)","category":"page"},{"location":"types/policy/#E4ST.EmissionPrice","page":"Policy","title":"E4ST.EmissionPrice","text":"struct EmissionPrice <: Policy\n\nEmission Price - A price on a certain emission for a given set of generators.\n\nname: name of the policy (Symbol)\nemis_col: name of the emission rate column in the gen table (ie. emis_co2) (Symbol)\nprices: OrderedDict of prices by year. Given as price per unit of emissions (ie. $/short ton)\nyears_after_ref_min: Min (inclusive) number of years the sim year can be after gen reference year (ie. yearon, yearretrofit). If ref year is year_on then this would be equivaled to min gen age. This is rarely used in real policy, so be careful if changing from default value\nyears_after_ref_max: Max (inclusive) number of years the sim year can be after gen reference year (ie. yearon, yearretrofit). If ref year is year_on then this would be equivaled to max gen age. This is rarely used in real policy, so be careful if changing from default value\nref_year_col: Column name to use as reference year for min and max above. Must be a year column. If this is :yearon, then the yearsafterref filters will filter gen age. If this is :yearretrofit, the the yearsafterref filters will filter by time since retrofit. This is rarely used in real policy, so be careful if changing from default value\ngen_filters: OrderedDict of generator filters\nhour_filters: OrderedDict of hour filters\n\n\n\n\n\n","category":"type"},{"location":"types/policy/#E4ST.modify_model!-Tuple{EmissionPrice, Any, Any, Any}","page":"Policy","title":"E4ST.modify_model!","text":"E4ST.modify_model!(pol::EmissionPrice, config, data, model)\n\nAdds a column to the gen table containing the emission price as a per MWh value (gen emission rate * emission price).  Adds this as a PerMWhGen price to the objective function using add_obj_term!\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/reserve-requirement/#Reserve-Requirements","page":"Reserve Requirements","title":"Reserve Requirements","text":"","category":"section"},{"location":"types/modifications/reserve-requirement/","page":"Reserve Requirements","title":"Reserve Requirements","text":"ReserveRequirement","category":"page"},{"location":"types/modifications/reserve-requirement/#E4ST.ReserveRequirement","page":"Reserve Requirements","title":"E4ST.ReserveRequirement","text":"ReserveRequirement <: Modification\n\nRepresentation of reserve requirement, such that the sum of eligible power injection capacity in the region (including both generators and storage devices) is constrained to be greater than or equal to some percentage above the load.\n\nKeyword arguments:\n\nname - name of the modification\nfilters - the filters for the generating, storage, and load regions.  Defaults to no filtering.\ncredit_gen - the Crediting for the generators, defaults to AvailabilityFactorCrediting\ncredit_stor - the Crediting for the storage facilities (see Storage), defaults to StandardStorageReserveCrediting\nrequirements - an OrderedDict{Symbol, Float64} mapping a year symbol to a percent requirement of required reserve above the load.\nload_type - a String for what type of load to base the requirement off of.  Can be either: \nplserv - (default), served load power\nplnom - nominal load power.\n\nAdds results:\n\n(:gen, :<name>_rebate) - the total rebate for generators, for satisfying the reserve requirement.  This is payed for by electricity users.\n(:storage, :<name>_rebate) - (only added if storage included) the total rebate for storage units, for satisfying the reserve requirement.  This is payed for by electricity users.\n\n\n\n\n\n","category":"type"},{"location":"inputs/branch/#Branch-Table","page":"Branch Table","title":"Branch Table","text":"","category":"section"},{"location":"inputs/branch/","page":"Branch Table","title":"Branch Table","text":"Table representing all existing branches (AC transmission lines) to be modeled.  See also DCLine","category":"page"},{"location":"inputs/branch/","page":"Branch Table","title":"Branch Table","text":"Note that the Branch Table does not contain DC transmission lines.","category":"page"},{"location":"inputs/branch/","page":"Branch Table","title":"Branch Table","text":"setup_table!(config, data, ::Val{:branch})\nsummarize_table(::Val{:branch})","category":"page"},{"location":"inputs/branch/#E4ST.setup_table!-Tuple{Any, Any, Val{:branch}}","page":"Branch Table","title":"E4ST.setup_table!","text":"setup_table!(config, data, ::Val{:branch})\n\nSets up the branch table.\n\nFlips f_bus_idx and t_bus_idx so that f_bus_idx < t_bus_idx\nMakes bus[:connectedbranchidxs] which contains a vector of the signed index of each branch leaving that bus. (+ for f_bus_idx, - for to_bus_idx). \n\n\n\n\n\n","category":"method"},{"location":"inputs/branch/#E4ST.summarize_table-Tuple{Val{:branch}}","page":"Branch Table","title":"E4ST.summarize_table","text":"summarize_table(::Val{:branch})\n\ncolumn_name data_type unit required description\nf_bus_idx Int64 E4ST.NA true The index of the bus table that the branch originates from\nt_bus_idx Int64 E4ST.NA true The index of the bus table that the branch goes to\nstatus Bool E4ST.NA false Whether or not the branch is in service\nx Float64 E4ST.PU true Per-unit reactance of the line (resistance assumed to be 0 for DC-OPF)\npflow_max Float64 E4ST.MWFlow true Maximum power flowing through the branch\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#Storage","page":"Storage","title":"Storage","text":"","category":"section"},{"location":"types/modifications/storage/","page":"Storage","title":"Storage","text":"Storage\nmodify_raw_data!(::Storage, config, data)\nmodify_setup_data!(::Storage, config, data)\nmodify_model!(::Storage, config, data, model)\nmodify_results!(::Storage, config, data)\nsave_updated_storage_table(config, data)\nsummarize_table(::Val{:storage})\nsummarize_table(::Val{:build_storage})","category":"page"},{"location":"types/modifications/storage/#E4ST.Storage","page":"Storage","title":"E4ST.Storage","text":"mutable struct Storage <: Modification\n\nStorage(;name, file, build_file=\"\")\n\nStorage is represented over sets of time-weighted sequential representative hours for which the following must hold true, for a given storage device:\n\nNet charge over the interval must equal zero.\nTotal charge of the device cannot exceed its maximum charge, or go below zero.\nInitial charge over an interval can be anywhere between 0 and the maximum charge, and is the same initial charge for each time interval.\n\nArguments\n\nname - the name of the Modification.\nfile - the filename of the storage table, where each row represents a storage device. See also summarize_table(::Val{:storage})\nbuild_file - the filename of the buildable storage table, where each row represents a specification for buildable storage.  See also summarize_table(::Val{:build_storage})\n\nVariables Introduced\n\npcap_stor[stor_idx, yr_idx] - The discharge power capacity, in MW, of the storage device.\npcharge_stor[stor_idx, yr_idx, hr_idx] - The charge power, in MW, for a given hour.\npdischarge_stor[stor_idx, yr_idx, hr_idx] - The discharged power, in MW, for a given hour.\ne0_stor[stor_idx] - The starting charge energy (in MWh) for each interval.\n\nConstraints Introduced\n\ncons_stor_charge_bal[stor_idx, yr_idx, int_idx] - the charge balancing equation - net charge in each interval is 0\ncons_stor_charge_max[stor_idx, yr_idx, int_idx, _hr_idx] - constrain the stored energy in each hour of each interval to be less than the maximum (function of pcap_stor and the discharge duration column of the storage table).  Note _hr_idx is the index within the interval, not the normal hr_idx\ncons_stor_charge_min[stor_idx, yr_idx, int_idx, _hr_idx] - constrain the stored energy in each hour of each interval to be greater than zero.  Note _hr_idx is the index within the interval, not the normal hr_idx\ncons_pcap_stor_noadd[stor_idx, yr_idx; years[yr_idx] >= storage.year_on[stor_idx]] - constrain the capacity to be non-increasing after being built. (only in multi-year simulations)\ncons_pcap_stor_prebuild[stor_idx, yr_idx; years[yr_idx] < storage.year_on[stor_idx]] - constrain the capacity to be zero before being built. (should only happen in multi-year simulations)\ncons_pcap_stor_exog[stor_idx, yr_idx] - constrain the exogenous, unbuilt capacity to equal pcap0 for the first year >= its build year.\n\nObjective Terms\n\ncapex_obj_stor - the capital expenditures to build the storage device, only non-zero in the build year.  (function of pcap_stor and capex, and year_on)\nfom_stor - the fixed operation and maintenance costs for the storage device (function of pcap_stor and fom from the storage table)\nvom_stor - the variable operation and maintenance costs for the storage device (function of pdischarge_stor, the vom column of the storage table, and the hour weights get_hour_weights)\n\nPower Balancing Equation\n\nEach storage device can either be on the \"gen\" side or the \"load\" side, as specified by the side column.\n\n\"gen\" side:\npcharge_stor gets subtracted from pgen_bus\npdischarge_stor gets added to pgen_bus\n\"load\" side:\npcharge_stor gets added to plserv_bus\npdischarge_stor gets subtracted from plserv_bus\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/storage/#E4ST.modify_raw_data!-Tuple{Storage, Any, Any}","page":"Storage","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(mod::Modification, config, data, model)\n\nChange the raw data with mod.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#E4ST.modify_setup_data!-Tuple{Storage, Any, Any}","page":"Storage","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(mod::Modification, config, data, model)\n\nChange the setup data with mod.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#E4ST.modify_model!-Tuple{Storage, Any, Any, Any}","page":"Storage","title":"E4ST.modify_model!","text":"modify_model!(mod::Modification, config, data, model)\n\nApply mod to the model, called in setup_model\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#E4ST.modify_results!-Tuple{Storage, Any, Any}","page":"Storage","title":"E4ST.modify_results!","text":"modify_results!(mod::Storage, config, data)\n\nModify battery results.  Add columns to the storage table for:\n\npcap - discharge capacity of the storage device, in MW.\npcharge - the charging rate, in MW\npdischarge - the discharging rate, in MW\necharge - the energy charged in each representative hour (including losses)\nedischarge - Energy that was discharged by the storage device\nploss - Power that was lost by the battery, counted as served load equal to pcharge * (1-η)\neloss - Energy that was lost by the battery, counted as served load\npcap_inv_sim - power discharge capacity invested in the sim\necap_inv_sim - 8760 * pcapinvsim\n\nAlso saves the updated storage table via save_updated_storage_table.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#E4ST.save_updated_storage_table-Tuple{Any, Any}","page":"Storage","title":"E4ST.save_updated_storage_table","text":"save_updated_storage_table(config, data)\n\nSaves the updated storage table with any additional storage units, updated capacities, etc.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#E4ST.summarize_table-Tuple{Val{:storage}}","page":"Storage","title":"E4ST.summarize_table","text":"summarize_table(::Val{:storage})\n\ncolumn_name data_type unit required description\nbus_idx Int64 E4ST.NA true The index of the bus table that the storage device corresponds to\nstatus Bool E4ST.NA false Whether or not the storage device is in service\nbuild_status InlineStrings.String15 E4ST.NA true Whether the storage device is built, 'new, or unbuilt. All storage devices marked new when the storage file is read in will be changed to built.  Can also be changed to retired_exog or retired_endog after the simulation is run.  See update_build_status!\nbuild_type AbstractString E4ST.NA true Whether the storage device is 'real', 'exog' (exogenously built), or 'endog' (endogenously built)\nbuild_id AbstractString E4ST.NA true Identifier of the build row.  For pre-existing storage devices not specified in the build file, this is usually left empty\nyear_on E4ST.YearString E4ST.Year true The first year of operation for the storage device. (For new devices this is also the year it was built)\nyear_unbuilt E4ST.YearString E4ST.Year false The latest year the generator was known not to be built.  Defaults to year_on - 1.  Used for past capex accounting.\necon_life Float64 E4ST.NumYears true The number of years in the economic lifetime of the storage device.\nyear_off E4ST.YearString E4ST.Year true The first year that the storage unit is no longer operating in the simulation, computed from the simulation.  Leave as y9999 if an existing storage unit that has not been retired in the simulation yet.\nyear_shutdown E4ST.YearString E4ST.Year true The forced (exogenous) shutdown year for the storage unit.\npcap_inv Float64 E4ST.MWCapacity true Original invested nameplate power generation capacity for the storage device.  This is the original invested capacity of exogenously built storage devices (even if there have been retirements ), and the original invested capacity in year_on for endogenously built storage devices.\npcap0 Float64 E4ST.MWCapacity true Starting nameplate power discharge capacity for the storage device\npcap_min Float64 E4ST.MWCapacity true Minimum nameplate power discharge capacity of the storage device (normally set to zero to allow for retirement)\npcap_max Float64 E4ST.MWCapacity true Maximum nameplate power discharge capacity of the storage device\nvom Float64 E4ST.DollarsPerMWhGenerated true Variable operation and maintenance cost per MWh of energy discharged\nfom Float64 E4ST.DollarsPerMWCapacityPerHour true Hourly fixed operation and maintenance cost for a MW of discharge capacity\ncapex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for a MW of discharge capacity\ntransmission_capex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour false Hourly capital expenditures for the transmission supporting a MW of discharge capacity\nroutine_capex Float64 E4ST.DollarsPerMWCapacityPerHour true Routine capital expenditures for a MW of discharge capacity\npast_invest_cost Float64 E4ST.DollarsPerMWCapacityPerHour false Investment costs per MW of initial capacity per hour, for past investments\npast_invest_subsidy Float64 E4ST.DollarsPerMWCapacityPerHour false Investment subsidies from govt. per MW of initial capacity per hour, for past investments\nduration_discharge Float64 E4ST.Hours true Number of hours to fully discharge the storage device, from full.\nduration_charge Float64 E4ST.Hours false Number of hours to fully charge the empty storage device from empty. (Defaults to equal duration_discharge)\nstorage_efficiency Float64 E4ST.MWhDischargedPerMWhCharged true The round-trip efficiency of the battery.\nside String E4ST.NA true The side of the power balance equation to add the charging/discharging to.  Can be \"gen\" or \"load\"\nhour_groupby String E4ST.NA true The column of the hours table to group by.  For example day\nhour_duration String E4ST.NA true The column of the hours table specifying the duration of each representatibe hour\nhour_order String E4ST.NA true The column of the hours table specifying the sequence of the hours.\nreg_factor Float64 E4ST.NA true The percentage of power that dispatches to a cost-of-service regulated market\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/storage/#E4ST.summarize_table-Tuple{Val{:build_storage}}","page":"Storage","title":"E4ST.summarize_table","text":"summarize_table(::Val{:build_storage})\n\ncolumn_name data_type unit required description\narea AbstractString E4ST.NA true The area with which to filter by. I.e. \"state\". Leave blank to not filter by area.\nsubarea AbstractString E4ST.NA true The subarea to include in the filter.  I.e. \"maryland\".  Leave blank to not filter by area.\nstatus Bool E4ST.NA false Whether or not the storage device is in service\nbuild_status InlineStrings.String15 E4ST.NA true Whether the storage device is built, 'new, or unbuilt. All storage devices marked new when the storage file is read in will be changed to built.  Can also be changed to retired_exog or retired_endog after the simulation is run.  See update_build_status!\nbuild_type AbstractString E4ST.NA true Whether the storage device is 'real', 'exog' (exogenously built), or 'endog' (endogenously built)\nbuild_id AbstractString E4ST.NA true Identifier of the build row.  Each storage device made using this build spec will inherit this build_id\nyear_on E4ST.YearString E4ST.Year true The first year of operation for the storage device. (For new devices this is also the year it was built)\necon_life Float64 E4ST.NumYears true The number of years in the economic lifetime of the storage device.\nage_shutdown Float64 E4ST.NumYears true The age at which the storage device is no longer operating.  I.e. if year_on = y2030 and age_shutdown = 20, then capacity will be 0 in y2040.\nyear_on_min E4ST.YearString E4ST.Year true The first year in which a storage device can be built/come online (inclusive). Storage device with no restriction and exogenously built gens will be left blank\nyear_on_max E4ST.YearString E4ST.Year true The last year in which a storage device can be built/come online (inclusive). Storage devices with no restriction and exogenously built gens will be left blank\npcap0 Float64 E4ST.MWCapacity true Starting nameplate power discharge capacity for the storage device\npcap_min Float64 E4ST.MWCapacity true Minimum nameplate power discharge capacity of the storage device (normally set to zero to allow for retirement)\npcap_max Float64 E4ST.MWCapacity true Maximum nameplate power discharge capacity of the storage device\nvom Float64 E4ST.DollarsPerMWhGenerated true Variable operation and maintenance cost per MWh of energy discharged\nfom Float64 E4ST.DollarsPerMWCapacityPerHour true Hourly fixed operation and maintenance cost for a MW of discharge capacity\ncapex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for a MW of discharge capacity\ntransmission_capex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for the transmission supporting a MW of discharge capacity\nroutine_capex Float64 E4ST.DollarsPerMWCapacityPerHour true Routing capital expenditures for a MW of discharge capacity\nduration_discharge Float64 E4ST.Hours true Number of hours to fully discharge the storage device, from full.\nduration_charge Float64 E4ST.Hours false Number of hours to fully charge the empty storage device from empty. (Defaults to equal duration_discharge)\nstorage_efficiency Float64 E4ST.MWhDischargedPerMWhCharged true The round-trip efficiency of the device.\nside String E4ST.NA true The side of the power balance equation to add the charging/discharging to.  Can be \"gen\" or \"load\"\nhour_groupby String E4ST.NA true The column of the hours table to group by.  For example day\nhour_duration String E4ST.NA true The column of the hours table specifying the duration of each representatibe hour\nhour_order String E4ST.NA true The column of the hours table specifying the sequence of the hours.\n\n\n\n\n\n","category":"method"},{"location":"inputs/config/#Config-File","page":"Config File","title":"Config File","text":"","category":"section"},{"location":"inputs/config/","page":"Config File","title":"Config File","text":"read_config\nsummarize_config\nsave_config\ncheck_config!\nsummarize_table(::Symbol)\nmake_out_path!\nget_out_path","category":"page"},{"location":"inputs/config/#E4ST.read_config","page":"Config File","title":"E4ST.read_config","text":"read_config(filename; kwargs...) -> config::OrderedDict{Symbol,Any}\n\nread_config(filenames; kwargs...) -> config::OrderedDict{Symbol,Any}\n\nread_config(path; kwargs...) -> config::OrderedDict{Symbol, Any}\n\nLoad the config file from filename, inferring any necessary settings as needed.  If path given, checks for joinpath(path, \"config.yml\").  This can be used with the out_path returned by run_e4st  See read_data to see how the config is used.  If multiple filenames given, (in a vector, or separated by commas) merges them, preserving the settings found in the last file, when there are conflicts, appending the list of Modifications.  Uses summarize_config to infer defaults, when applicable.  Any specified kwargs are added to the config, over-writing anything except the list of Modifications.  Note\n\nThe Config File is a file that fully specifies all the necessary information.  Note that when filenames are given as a relative path, they are assumed to be relative to the location of the config file.\n\nname required default description\nbase_out_path true nothing The path (relative or absolute) to the desired output folder.  This folder doesn't necessarily need to exist.  The code will make it for you if it doesn't exist yet.  E4ST will make a timestamped folder within base_out_path, and store that new path into config[out_path].  This is to prevent processes from overwriting one another.\ngen_file true nothing The filepath (relative or absolute) to the generator table.  See summarize_table(::Val{:gen}).\nbus_file true nothing The filepath (relative or absolute) to the bus table.  See summarize_table(::Val{:bus}).\nbranch_file true nothing The filepath (relative or absolute) to the branch table.  See summarize_table(::Val{:branch}).\nhours_file true nothing The filepath (relative or absolute) to the hours table.  See summarize_table(::Val{:hours}).\nnominal_load_file true nothing The filepath (relative or absolute) to the time representation.  See summarize_table(::Val{:nominal_load})\nyears true nothing a list of years to run in the simulation specified as a string.  I.e. \"y2030\"\noptimizer true nothing The optimizer type and attributes to use in solving the linear program.  The type field should be always be given, (i.e. type: HiGHS) as well as each of the solver options you wish to set.  E4ST is a BYOS (Bring Your Own Solver :smile:) library, with default attributes for HiGHS and Gurobi.  For all other solvers, you're on your own to provide a reasonable set of attributes.  To see a full list of solvers with work with JuMP.jl, see here.\nmods false OrderedCollections.OrderedDict{Symbol, E4ST.Modification}() A list of Modifications specifying changes for how E4ST runs.  See the Modification for information on what they are, how to add them to a config file.\nyear_gen_data true nothing The year string (i.e. y2016) corresponding to the data year of the generator table.\nlog_model_summary false false Whether or not to log a numerical summary of the model.  Useful for debugging, but can take a while if the model is large.\nout_path false nothing the path to output to.  If this is not provided, an output path will be created make_out_path!.\nother_config_files false nothing A list of other config files to read.  Note that the options in the parent file will be honored.\naf_file false nothing The filepath (relative or absolute) to the availability factor table.  See summarize_table(::Val{:af_table})\ncf_threshold false 0.001 The threshold below which the maximum capacity factor is considered to be zero.  This helps with numerical performance of the solver.  For example, a solar unit with an hourly average CF of 0.00001 will not operate, with the default cf_threshold of 1e-3.\niter false E4ST.RunOnce() The Iterable object to specify the way the sim should iterate.  If nothing specified, defaults to run a single time via RunOnce.  Specify the Iterable type, and all keyword arguments.\nload_shape_file false nothing a file for specifying the hourly shape of load elements.  See summarize_table(::Val{:load_shape})\nload_match_file false nothing a file for specifying annual load energy to match for sets.  See summarize_table(::Val{:load_match})\nload_add_file false nothing a file for specifying additional load energy, after matching.  See summarize_table(::Val{:load_add})\nload_add_file false nothing a file for specifying additional load energy, after matching.  See summarize_table(::Val{:load_add})\nbuild_gen_file false nothing a file for specifying generators that could get built.  See summarize_table(::Val{:build_gen})\ngentype_genfuel_file false nothing a file for storing gentype-genfuel pairings.  See summarize_table(::Val{:genfuel})\nsummary_table_file false nothing a file for giving information about additional columns not specified in summarize_table\nsave_data false true A boolean specifying whether or not to save the loaded data to file for later use (i.e. by specifying a data_file for future simulations).\ndata_file false nothing The filepath (relative or absolute) to the data file (a serialized julia object).  If this is provided, it will use this instead of loading data from all the other files.\nresults_formulas_file false nothing The filepath (relative or absolute) to the results formulas file.  See summarize_table(::Val{:results_formulas})\nsave_model_presolve false false A boolean specifying whether or not to save the model before solving it, for later use (i.e. by specifying a model_presolve_file for future sims). Defaults to false\nmodel_presolve_file false nothing The filepath (relative or absolute) to the unsolved model.  If this is provided, it will use this instead of creating a new model.\nsave_data_parsed false true A boolean specifying whether or not to save the raw results after solving the model.  This could be useful for calling process_results!(config) in the future. Defaults to true\nsave_data_processed false true A boolean specifying whether or not to save the processed results after solving the model.  Defaults to true.\nobjective_scalar false 1.0e6 This is specifies how much to scale the objective by for the sake of the solver.  Does not impact any user-created expressions or shadow prices from the raw results, as they get scaled back.  (Defaults to 1e6)\npgen_scalar false 1000.0 This specifies how much to scale pgen by in the conspgenmax constraint.  Helps with numerical stability if there are small availability factors present.  See also cf_threshold\npcap_retirement_threshold false 1.0e-6 This is the minimum pcap threshold (in MW) for new generators to be kept.  Defaults to 1e-6 (i.e. 1W).  See also save_updated_gen_table\nvoll false 5000 This is the assumed value of lost load for which the objective function will be penalized for every MWh of curtailed load.\nlogging false true This specifies whether or not E4ST will log to get_out_path(config, \"E4ST.log\"). Options include true, false, or \"debug\".  See start_logging! for more info.\neor_leakage_rate false 0.5 The assumed rate (between 0 and 1) at which CO₂ stored in Enhanced Oil Recovery (EOR) leaks back into the atmosphere.\nline_loss_rate false 0.1 The assumed electrical loss rate from generation to consumption, given as a ratio between 0 and 1.  Default is 0.1, or 10% energy loss\nline_loss_type false plserv The term in the power balancing equation that gets penalized with line losses.  Can be \"pflow\" or \"plserv\". Using \"pflow\" is more accurate in that it accounts for only losses on power coming from somewhere else, at the expense of a larger problem size and greater solve time.  Default is plserv due to increased runtime with pflow\ndistribution_cost false 60 The assumed cost per MWh of served power, for the transmission and distribution of the power.\nbio_pctco2e false 0.273783186 The fraction of biomass co2 emissions that are considered new to the atmostphere. 0.225 metric tons/MWh * (2204 short tons/2000 metric tons) / 0.904 short tons/MWh\nng_ch4_fuel_content false 0.000434 Natural gas methane fuel content. (Short ton/MMBtu)\ncoal_ch4_fuel_content false 0.000175 Coal methane fuel content. (Short ton/MMBtu)\nwacc false 0.0544 Assumed Weighted Average Cost of Capital (used as discount rate), currently only used for calculating ptc capex adjustment but should be the same as the wacc/discount rate used to calculate annualized generator costs. Current value (0.0544) was using in annulaizing ATB 2022 costs.\n\nExample Config File\n\nbase_out_path:    \"../out/3bus\"\ngen_file:    \"../data/3bus/gen.csv\"\nbus_file:    \"../data/3bus/bus.csv\"\nbranch_file: \"../data/3bus/branch.csv\"\nhours_file:   \"../data/3bus/hours.csv\"\naf_file:     \"../data/3bus/af.csv\"\nnominal_load_file:     \"../data/3bus/load.csv\"\ngentype_genfuel_file: \"../data/3bus/gentype_genfuel.csv\"\nbuild_gen_file: \"../data/3bus/build_gen.csv\"\ntest_param1: \"RIGHT\" # This should not get overwritten by config_other\nyear_gen_data: y2020\nother_config_files:\n  - \"config_other.yml\"\nyears:\n  - y2030\n  - y2035\n  - y2040\noptimizer:\n  type: \"HiGHS\" # See available options here: https://docs.juliahub.com/HiGHS/WFic5/0.3.1/\n  dual_feasibility_tolerance: 1e-5\n  log_file: HiGHS.log\n  log_to_console: false\n  solver: simplex # \"ipm\" is probably preferred for larger problems, but it logs to console due to an issue\nmods:\n  example_policy:\n    type: \"ExamplePolicyType\"\n    value: 0\n    some_parameter:\n      - \"This makes an \"\n      - \"array of strings.\"\n      - \"Cool, right?\"\n    other_parameter:\n      name: \"This makes an OrderedDict\"\n  other_mod:\n    type: \"OtherModificationType\"\n    value: 0\n    custom_parameter: \"hello!!!\"\n\n\n\n\n\n\n\n","category":"function"},{"location":"inputs/config/#E4ST.summarize_config","page":"Config File","title":"E4ST.summarize_config","text":"summarize_config() -> summary::DataFrame\n\nSummarizes the config, with columns for:\n\nname - the property name, i.e. key\nrequired - whether or not the property is required\ndefault - default value of this property\ndescription\n\nname required default description\nbase_out_path true nothing The path (relative or absolute) to the desired output folder.  This folder doesn't necessarily need to exist.  The code will make it for you if it doesn't exist yet.  E4ST will make a timestamped folder within base_out_path, and store that new path into config[out_path].  This is to prevent processes from overwriting one another.\ngen_file true nothing The filepath (relative or absolute) to the generator table.  See summarize_table(::Val{:gen}).\nbus_file true nothing The filepath (relative or absolute) to the bus table.  See summarize_table(::Val{:bus}).\nbranch_file true nothing The filepath (relative or absolute) to the branch table.  See summarize_table(::Val{:branch}).\nhours_file true nothing The filepath (relative or absolute) to the hours table.  See summarize_table(::Val{:hours}).\nnominal_load_file true nothing The filepath (relative or absolute) to the time representation.  See summarize_table(::Val{:nominal_load})\nyears true nothing a list of years to run in the simulation specified as a string.  I.e. \"y2030\"\noptimizer true nothing The optimizer type and attributes to use in solving the linear program.  The type field should be always be given, (i.e. type: HiGHS) as well as each of the solver options you wish to set.  E4ST is a BYOS (Bring Your Own Solver :smile:) library, with default attributes for HiGHS and Gurobi.  For all other solvers, you're on your own to provide a reasonable set of attributes.  To see a full list of solvers with work with JuMP.jl, see here.\nmods false OrderedCollections.OrderedDict{Symbol, E4ST.Modification}() A list of Modifications specifying changes for how E4ST runs.  See the Modification for information on what they are, how to add them to a config file.\nyear_gen_data true nothing The year string (i.e. y2016) corresponding to the data year of the generator table.\nlog_model_summary false false Whether or not to log a numerical summary of the model.  Useful for debugging, but can take a while if the model is large.\nout_path false nothing the path to output to.  If this is not provided, an output path will be created make_out_path!.\nother_config_files false nothing A list of other config files to read.  Note that the options in the parent file will be honored.\naf_file false nothing The filepath (relative or absolute) to the availability factor table.  See summarize_table(::Val{:af_table})\ncf_threshold false 0.001 The threshold below which the maximum capacity factor is considered to be zero.  This helps with numerical performance of the solver.  For example, a solar unit with an hourly average CF of 0.00001 will not operate, with the default cf_threshold of 1e-3.\niter false E4ST.RunOnce() The Iterable object to specify the way the sim should iterate.  If nothing specified, defaults to run a single time via RunOnce.  Specify the Iterable type, and all keyword arguments.\nload_shape_file false nothing a file for specifying the hourly shape of load elements.  See summarize_table(::Val{:load_shape})\nload_match_file false nothing a file for specifying annual load energy to match for sets.  See summarize_table(::Val{:load_match})\nload_add_file false nothing a file for specifying additional load energy, after matching.  See summarize_table(::Val{:load_add})\nload_add_file false nothing a file for specifying additional load energy, after matching.  See summarize_table(::Val{:load_add})\nbuild_gen_file false nothing a file for specifying generators that could get built.  See summarize_table(::Val{:build_gen})\ngentype_genfuel_file false nothing a file for storing gentype-genfuel pairings.  See summarize_table(::Val{:genfuel})\nsummary_table_file false nothing a file for giving information about additional columns not specified in summarize_table\nsave_data false true A boolean specifying whether or not to save the loaded data to file for later use (i.e. by specifying a data_file for future simulations).\ndata_file false nothing The filepath (relative or absolute) to the data file (a serialized julia object).  If this is provided, it will use this instead of loading data from all the other files.\nresults_formulas_file false nothing The filepath (relative or absolute) to the results formulas file.  See summarize_table(::Val{:results_formulas})\nsave_model_presolve false false A boolean specifying whether or not to save the model before solving it, for later use (i.e. by specifying a model_presolve_file for future sims). Defaults to false\nmodel_presolve_file false nothing The filepath (relative or absolute) to the unsolved model.  If this is provided, it will use this instead of creating a new model.\nsave_data_parsed false true A boolean specifying whether or not to save the raw results after solving the model.  This could be useful for calling process_results!(config) in the future. Defaults to true\nsave_data_processed false true A boolean specifying whether or not to save the processed results after solving the model.  Defaults to true.\nobjective_scalar false 1.0e6 This is specifies how much to scale the objective by for the sake of the solver.  Does not impact any user-created expressions or shadow prices from the raw results, as they get scaled back.  (Defaults to 1e6)\npgen_scalar false 1000.0 This specifies how much to scale pgen by in the conspgenmax constraint.  Helps with numerical stability if there are small availability factors present.  See also cf_threshold\npcap_retirement_threshold false 1.0e-6 This is the minimum pcap threshold (in MW) for new generators to be kept.  Defaults to 1e-6 (i.e. 1W).  See also save_updated_gen_table\nvoll false 5000 This is the assumed value of lost load for which the objective function will be penalized for every MWh of curtailed load.\nlogging false true This specifies whether or not E4ST will log to get_out_path(config, \"E4ST.log\"). Options include true, false, or \"debug\".  See start_logging! for more info.\neor_leakage_rate false 0.5 The assumed rate (between 0 and 1) at which CO₂ stored in Enhanced Oil Recovery (EOR) leaks back into the atmosphere.\nline_loss_rate false 0.1 The assumed electrical loss rate from generation to consumption, given as a ratio between 0 and 1.  Default is 0.1, or 10% energy loss\nline_loss_type false plserv The term in the power balancing equation that gets penalized with line losses.  Can be \"pflow\" or \"plserv\". Using \"pflow\" is more accurate in that it accounts for only losses on power coming from somewhere else, at the expense of a larger problem size and greater solve time.  Default is plserv due to increased runtime with pflow\ndistribution_cost false 60 The assumed cost per MWh of served power, for the transmission and distribution of the power.\nbio_pctco2e false 0.273783186 The fraction of biomass co2 emissions that are considered new to the atmostphere. 0.225 metric tons/MWh * (2204 short tons/2000 metric tons) / 0.904 short tons/MWh\nng_ch4_fuel_content false 0.000434 Natural gas methane fuel content. (Short ton/MMBtu)\ncoal_ch4_fuel_content false 0.000175 Coal methane fuel content. (Short ton/MMBtu)\nwacc false 0.0544 Assumed Weighted Average Cost of Capital (used as discount rate), currently only used for calculating ptc capex adjustment but should be the same as the wacc/discount rate used to calculate annualized generator costs. Current value (0.0544) was using in annulaizing ATB 2022 costs.\n\n\n\n\n\n","category":"function"},{"location":"inputs/config/#E4ST.save_config","page":"Config File","title":"E4ST.save_config","text":"save_config(config) -> nothing\n\nsaves the config to the output folder specified inside the config file\n\n\n\n\n\n","category":"function"},{"location":"inputs/config/#E4ST.check_config!","page":"Config File","title":"E4ST.check_config!","text":"check_config!(config)\n\nEnsures that config has required fields listed in summarize_config\n\n\n\n\n\n","category":"function"},{"location":"inputs/config/#E4ST.summarize_table-Tuple{Symbol}","page":"Config File","title":"E4ST.summarize_table","text":"summarize_table(s::Symbol) -> summary::DataFrame\n\nReturns a summary of the table s.  Note that more information can be provided in the the summary_table, which contains a summary of all tables, including all information from summarize_table, plus additional columns specified.\n\nSee also get_table(data, name), read_summary_table!(config, data), get_table_summary(data, name)\n\n\n\n\n\n","category":"method"},{"location":"inputs/config/#E4ST.make_out_path!","page":"Config File","title":"E4ST.make_out_path!","text":"make_out_path!(config) -> nothing\n\nIf config[:out_path] provided, does nothing.  Otherwise, makes sure config[:base_out_path] exists, making it as needed.  Creates a new time-stamped folder via time_string, stores it into config[:out_path].  See get_out_path to create paths for output files. \n\n\n\n\n\n","category":"function"},{"location":"inputs/config/#E4ST.get_out_path","page":"Config File","title":"E4ST.get_out_path","text":"get_out_path(config, filename) -> path\n\nReturns joinpath(config[:out_path], filename)\n\n\n\n\n\n","category":"function"},{"location":"types/modifications/interface-limits/#Interface-Limits","page":"Interface Limits","title":"Interface Limits","text":"","category":"section"},{"location":"types/modifications/interface-limits/","page":"Interface Limits","title":"Interface Limits","text":"InterfaceLimit\nsummarize_table(::Val{:interface_limit})\nmodify_raw_data!(mod::InterfaceLimit, config, data)\nmodify_model!(mod::InterfaceLimit, config, data, model)","category":"page"},{"location":"types/modifications/interface-limits/#E4ST.InterfaceLimit","page":"Interface Limits","title":"E4ST.InterfaceLimit","text":"InterfaceLimit(;file)\n\nConstrain power flowing between regions for each representative hour. See summarize_table(::Val{:interface_limit}).\n\nmodify_raw_data!(mod::InterfaceLimit, config, data)\nmodify_model!(mod::InterfaceLimit, config, data, model)\n\nTo change the power flow min/max for each year and/or hour, see AdjustYearly and AdjustHourly.\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/interface-limits/#E4ST.summarize_table-Tuple{Val{:interface_limit}}","page":"Interface Limits","title":"E4ST.summarize_table","text":"summarize_table(::Val{:interface_limit})\n\ncolumn_name data_type unit required description\nname String E4ST.NA false Name of the interface limit, not used\ndescription String E4ST.NA false Description of the interface limit, not used.\nf_filter String E4ST.NA true The filter for the bus table specifiying the region the power is flowing from.  I.e. nation=>narnia, or state=>[angard, stormness]\nt_filter String E4ST.NA true The filter for the bus table specifiying the region the power is flowing to.\npflow_max Float64 E4ST.MWFlow false The maximum allowable power flow in the direction of f to t. If left as ±Inf, no constraint made.\npflow_min Float64 E4ST.MWFlow false The minimum allowable power flow in the direction of f to t.  Can be positive or negative.  If left as ±Inf, no constraint made.\neflow_yearly_max Float64 E4ST.MWhFlow false The yearly maximum allowable energy to flow in the direction of f to t. If left as ±Inf, no constraint made.\neflow_yearly_min Float64 E4ST.MWhFlow false The yearly minimum allowable energy to flow in the direction of f to t.  Can be positive or negative. If left as ±Inf, no constraint made.\nprice Float64 E4ST.DollarsPerMWhFlow false The price of net flow in the direction of f to t.\ninclude_dc Bool E4ST.NA false Whether or not to include DC lines in this interface limit.  If not provided, assumed that DC lines are not included\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/interface-limits/#E4ST.modify_raw_data!-Tuple{InterfaceLimit, Any, Any}","page":"Interface Limits","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(mod::InterfaceLimit, config, data)\n\nReads the interface limit table from mod.file and stores it to data[:interface_limit].\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/interface-limits/#E4ST.modify_model!-Tuple{InterfaceLimit, Any, Any, Any}","page":"Interface Limits","title":"E4ST.modify_model!","text":"modify_model!(mod::InterfaceLimit, config, data, model)\n\nGathers each of the branches (forward and reverse) for each of the rows of the interface_limit table.\nCreates an expression pflow_if[if_idx, yr_idx, hr_idx] for the power flowing, in MW, in each interface.  This includes\nThe sum of all of the pflow_branch terms for branches that are flowing in the direction of from to to.\nNet the sum of all of the pflow_branch terms for branches that are flowing in the direction of to to from.\nCreates min and max constraints cons_pflow_if_min[if_idx, yr_idx, hr_idx] and cons_pflow_if_max[if_idx, yr_idx, hr_idx] for each interface limit, for each year and hour in which the limit is finite, and there are qualifying pflow_branch variables in the interface.\nCreates min and max constraints cons_eflow_if_min[if_idx, yr_idx] and cons_eflow_if_max[if_idx, yr_idx] for each interface limit, for each year in which the limit is finite, and there are qualifying pflow_branch variables in the interface.\nCreates expression interface_flow_cost_obj[if_idx, yr_idx, hr_idx] for the cost of interface flow, and adds it to the objective.\n\n\n\n\n\n","category":"method"},{"location":"develop/dev_intro/#E4ST.jl-Development-Handbook","page":"-","title":"E4ST.jl Development Handbook","text":"","category":"section"},{"location":"develop/dev_intro/","page":"-","title":"-","text":"This purpose of this documentation is to assist in the development of the E4ST model, primarily by RFF employees but also for potential outside collaborators. It is meant to compliment the primary documentation by outlining some of the thinking and best practices that go into E4ST. ","category":"page"},{"location":"develop/dev_intro/","page":"-","title":"-","text":"~TODO:Link to other documents~","category":"page"},{"location":"inputs/load/#Load-Power","page":"Load","title":"Load Power","text":"","category":"section"},{"location":"inputs/load/#Load-Table","page":"Load","title":"Load Table","text":"","category":"section"},{"location":"inputs/load/","page":"Load","title":"Load","text":"setup_table!(config, data, ::Val{:nominal_load})\nsummarize_table(::Val{:nominal_load})","category":"page"},{"location":"inputs/load/#E4ST.setup_table!-Tuple{Any, Any, Val{:nominal_load}}","page":"Load","title":"E4ST.setup_table!","text":"setup_table!(config, data, ::Val{:nominal_load})\n\nSet up the load table.\n\nAlso calls the following:\n\nshape_nominal_load!(config, data) - scales hourly load power by an hourly load profile by arbitrary region\nmatch_nominal_load!(config, data) - matches annual load energy by arbitrary region\nadd_nominal_load!(config, data) - adds hourly load power by arbitrary region\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#E4ST.summarize_table-Tuple{Val{:nominal_load}}","page":"Load","title":"E4ST.summarize_table","text":"summarize_table(::Val{:nominal_load})\n\ncolumn_name data_type unit required description\nbus_idx Int64 E4ST.NA true The bus index of the load element\nplnom0 Float64 E4ST.MWLoad true The nominal load power of the load element\nload_type String E4ST.NA false The type of load represented by this load element.\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#Shaping-Hourly-Load","page":"Load","title":"Shaping Hourly Load","text":"","category":"section"},{"location":"inputs/load/","page":"Load","title":"Load","text":"shape_nominal_load!(config, data)\nsummarize_table(::Val{:load_shape})","category":"page"},{"location":"inputs/load/#E4ST.shape_nominal_load!-Tuple{Any, Any}","page":"Load","title":"E4ST.shape_nominal_load!","text":"shape_nominal_load!(config, data)\n\nShapes the hourly load to match profiles given in config[:load_shape_file].  See summarize_table(::Val{:load_shape}) for more details\n\nLoad power often changes on an hourly basis. The load_shape_table allows the user to provide hourly load profiles with which to scale the base load power for load regions, types, or even specific load elements.  Each row of the table represents a set of load elements, and the hourly load profile with which to scale them.  For load elements that fall in multiple sets, the hourly load will be scaled by each profile, in order.\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#E4ST.summarize_table-Tuple{Val{:load_shape}}","page":"Load","title":"E4ST.summarize_table","text":"summarize_table(::Val{:load_shape})\n\ncolumn_name data_type unit required description\narea String E4ST.NA true The area with which to filter by. I.e. \"state\". Leave blank to not filter by area.\nsubarea String E4ST.NA true The subarea to include in the filter.  I.e. \"maryland\".  Leave blank to not filter by area.\nload_type String E4ST.NA false The type of load represented for this load shape.  Leave blank to not filter by type.\nyear String E4ST.Year false The year to apply the load profile to, expressed as a year string prepended with a \"y\".  I.e. \"y2022\"\nstatus Bool E4ST.NA false Whether or not to use this shape adjustment\nh_ Float64 E4ST.Ratio true Load scaling factor of hour 1.  Include a column for each hour in the hours table.  I.e. :h1, :h2, ... :hn\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#Matching-Yearly-Load","page":"Load","title":"Matching Yearly Load","text":"","category":"section"},{"location":"inputs/load/","page":"Load","title":"Load","text":"match_nominal_load!(config, data)\nsummarize_table(::Val{:load_match})","category":"page"},{"location":"inputs/load/#E4ST.match_nominal_load!-Tuple{Any, Any}","page":"Load","title":"E4ST.match_nominal_load!","text":"match_nominal_load!(config, data)\n\nMatch the yearly load by area given in config[:load_match_file], updates the pd field of the data[:bus].  See summarize_table(::Val{:load_match}) for more details.\n\nOften, we want to force the total energy load for a set of load elements over a year to match load projections from a data source.  The load_match_table allows the user to provide yearly energy load targets, in MWh, to match.  The matching weights each hourly load by the number of hours spent at each of the representative hours, as provided in the hours table, converting from MW power load over the representative hour, into MWh.\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#E4ST.summarize_table-Tuple{Val{:load_match}}","page":"Load","title":"E4ST.summarize_table","text":"summarize_table(::Val{:load_match})\n\ncolumn_name data_type unit required description\narea String E4ST.NA true The area with which to filter by. I.e. \"state\". Leave blank to not filter by area.\nsubarea String E4ST.NA true The subarea to include in the filter.  I.e. \"maryland\".  Leave blank to not filter by area.\nload_type String E4ST.NA false The type of load represented for this load match.  Leave blank to not filter by type.\nstatus Bool E4ST.NA false Whether or not to use this match\ny_ Float64 E4ST.MWhLoad true The annual load energy to match for the weighted load of all load elements in the loads specified.  Include 1 column for each year being simulated.  I.e. \"y2030\", \"y2035\", ... To not match a specific year, make it -Inf\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#Adding-Hourly-Load","page":"Load","title":"Adding Hourly Load","text":"","category":"section"},{"location":"inputs/load/","page":"Load","title":"Load","text":"add_nominal_load!(config, data)\nsummarize_table(::Val{:load_add})","category":"page"},{"location":"inputs/load/#E4ST.add_nominal_load!-Tuple{Any, Any}","page":"Load","title":"E4ST.add_nominal_load!","text":"add_nominal_load!(config, data)\n\nAdd load power in config[:load_add_file] to load elements after the annual match in match_nominal_load!\n\nWe may wish to provide additional load after the match so that we can compare the difference.\n\n\n\n\n\n","category":"method"},{"location":"inputs/load/#E4ST.summarize_table-Tuple{Val{:load_add}}","page":"Load","title":"E4ST.summarize_table","text":"summarize_table(::Val{:load_add})\n\ncolumn_name data_type unit required description\narea String E4ST.NA true The area with which to filter by. I.e. \"state\". Leave blank to not filter by area.\nsubarea String E4ST.NA true The subarea to include in the filter.  I.e. \"maryland\".  Leave blank to not filter by area.\nload_type String E4ST.NA false The type of load represented for this load add.  Leave blank to not filter by type.\nyear String E4ST.Year false The year to apply the load profile to, expressed as a year string prepended with a \"y\".  I.e. \"y2022\"\nstatus Bool E4ST.NA false Whether or not to use this addition\nh_ Float64 E4ST.MWLoad true Amount of load power to add in hour _.  Include a column for each hour in the hours table.  I.e. :h1, :h2, ... :hn\n\n\n\n\n\n","category":"method"},{"location":"inputs/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"inputs/logging/","page":"Logging","title":"Logging","text":"In general, E4ST piggy-backs off of the Logging.jl interface.  To make a log statement, simply write:","category":"page"},{"location":"inputs/logging/","page":"Logging","title":"Logging","text":"@info \"Something informative\"\n@warn \"Some sort of warning\"\n@debug \"Debugging information, not printed unless config[:logging] == \\\"debug\\\"\"","category":"page"},{"location":"inputs/logging/#Documentation","page":"Logging","title":"Documentation","text":"","category":"section"},{"location":"inputs/logging/","page":"Logging","title":"Logging","text":"start_logging!(config)\nstop_logging!(config)\nlog_header(s)\nlog_start\nheader_string\ntime_string\ndate_string","category":"page"},{"location":"inputs/logging/#E4ST.start_logging!-Tuple{Any}","page":"Logging","title":"E4ST.start_logging!","text":"start_logging!(config)\n\nStarts logging according to config[:logging].  Possible options for config[:logging]:\n\ntrue (default): logs @info, @warning, and @error messages to config[:out_path]/E4ST.log\n\"debug\" - logs @debug, @info, @warning, and @error messages to config[:out_path]/E4ST.log\nfalse - no logging\n\nTo log things, you can use @info, @warn, or @debug as defined in Logging.jl.  Or you can use a convenience method for logging a header, log_header\n\nTo stop the logger and close its io stream, see stop_logging!(config)\n\n\n\n\n\n","category":"method"},{"location":"inputs/logging/#E4ST.stop_logging!-Tuple{Any}","page":"Logging","title":"E4ST.stop_logging!","text":"stop_logging!(config)\n\nStops logging to console, closes the io stream of the current logger.\n\n\n\n\n\n","category":"method"},{"location":"inputs/logging/#E4ST.log_header-Tuple{Any}","page":"Logging","title":"E4ST.log_header","text":"log_header(header)\n\nLogs a 3-line header string by calling @info header_string(header)\n\n\n\n\n\n","category":"method"},{"location":"inputs/logging/#E4ST.log_start","page":"Logging","title":"E4ST.log_start","text":"log_start(config)\n\nLogs any necessary info at the beginning of a run of E4ST\n\n\n\n\n\n","category":"function"},{"location":"inputs/logging/#E4ST.header_string","page":"Logging","title":"E4ST.header_string","text":"header_string(header) -> s\n\nReturns a 3-line header string\n\n\n\n\n\n","category":"function"},{"location":"inputs/logging/#E4ST.time_string","page":"Logging","title":"E4ST.time_string","text":"time_string() -> s\n\nReturns a time string in the format \"yymmdd_HHMMSS\"\n\n\n\n\n\n","category":"function"},{"location":"inputs/logging/#E4ST.date_string","page":"Logging","title":"E4ST.date_string","text":"date_string() -> s\n\nReturns a date string in the format \"yymmdd\"\n\n\n\n\n\n","category":"function"},{"location":"results/plotting/#Plotting-Results","page":"Plotting","title":"Plotting Results","text":"","category":"section"},{"location":"results/plotting/","page":"Plotting","title":"Plotting","text":"To plot results, see E4STPlots.jl","category":"page"},{"location":"inputs/gen/#Generator-Table","page":"Generator Table","title":"Generator Table","text":"","category":"section"},{"location":"inputs/gen/","page":"Generator Table","title":"Generator Table","text":"Table representing all existing generators to be modeled.","category":"page"},{"location":"inputs/gen/","page":"Generator Table","title":"Generator Table","text":"Note that the generator table does not contain Direct Air Capture, or Storage facilities.","category":"page"},{"location":"inputs/gen/","page":"Generator Table","title":"Generator Table","text":"summarize_table(::Val{:gen})","category":"page"},{"location":"inputs/gen/#E4ST.summarize_table-Tuple{Val{:gen}}","page":"Generator Table","title":"E4ST.summarize_table","text":"summarize_table(::Val{:gen})\n\ncolumn_name data_type unit required description\nbus_idx Int64 E4ST.NA true The index of the bus table that the generator corresponds to\nstatus Bool E4ST.NA false Whether or not the generator is in service\nbuild_status InlineStrings.String15 E4ST.NA true Whether the generator is built, 'new, or unbuilt. All generators marked new when the gen file is read in will be changed to built.  Can also be changed to retired_exog or retired_endog after the simulation is run.  See update_build_status!\nbuild_type AbstractString E4ST.NA true Whether the generator is 'real', 'exog' (exogenously built), or 'endog' (endogenously built)\nbuild_id AbstractString E4ST.NA true Identifier of the build row.  For pre-existing generators not specified in the build file, this is usually left empty\nyear_on E4ST.YearString E4ST.Year true The first year of operation for the generator. (For new gens this is also the year it was built)\nyear_unbuilt E4ST.YearString E4ST.Year false The latest year the generator was known not to be built.  Defaults to year_on - 1.  Used for past capex accounting.\necon_life Float64 E4ST.NumYears true The number of years in the economic lifetime of the generator.\nyear_off E4ST.YearString E4ST.Year true The first year that the generator is no longer operating in the simulation, computed from the simulation.  Leave as y9999 if an existing generator that has not been retired in the simulation yet.\nyear_shutdown E4ST.YearString E4ST.Year true The forced (exogenous) shutdown year for the generator.  Often equal to the yearon plus the econlife\ngenfuel AbstractString E4ST.NA true The fuel type that the generator uses\ngentype String E4ST.NA true The generation technology type that the generator uses\npcap_inv Float64 E4ST.MWCapacity true Original invested nameplate power generation capacity for the generator.  This is the original invested capacity of exogenously built generators (even if there have been retirements ), and the original invested capacity in year_on for endogenously built generators.\npcap0 Float64 E4ST.MWCapacity true Nameplate power generation capacity for the generator at the start of the simulation\npcap_min Float64 E4ST.MWCapacity true Minimum nameplate power generation capacity of the generator (normally set to zero to allow for retirement)\npcap_max Float64 E4ST.MWCapacity true Maximum nameplate power generation capacity of the generator\nvom Float64 E4ST.DollarsPerMWhGenerated true Variable operation and maintenance cost per MWh of generation\nfuel_price Float64 E4ST.DollarsPerMMBtu false Fuel cost per MMBtu of fuel used.  heat_rate column also necessary when supplying fuel_price\nheat_rate Float64 E4ST.MMBtuPerMWhGenerated false Heat rate,  or MMBtu of fuel consumed per MWh electricity generated (0 for generators that don't use combustion)\nfom Float64 E4ST.DollarsPerMWCapacityPerHour true Hourly fixed operation and maintenance cost for a MW of generation capacity\ncapex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for a MW of generation capacity.  For already-built generators, this is not accounted for in the optimization or accounting.  For accounting for investment costs and subsidies in built generators, use past_invest_cost and past_invest_subsidy\ntransmission_capex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for the transmission supporting a MW of generation capacity\nroutine_capex Float64 E4ST.DollarsPerMWCapacityPerHour true Routine capital expenditures for a MW of discharge capacity\npast_invest_cost Float64 E4ST.DollarsPerMWCapacityPerHour false Investment costs per MW of initial capacity per hour, for past investments\npast_invest_subsidy Float64 E4ST.DollarsPerMWCapacityPerHour false Investment subsidies from govt. per MW of initial capacity per hour, for past investments\ncf_min Float64 E4ST.MWhGeneratedPerMWhCapacity false The minimum capacity factor, or operable ratio of power generation to capacity for the generator to operate.  Take care to ensure this is not above the hourly availability factor in any of the hours, or else the model may be infeasible.  Set to zero by default.\ncf_max Float64 E4ST.MWhGeneratedPerMWhCapacity false The maximum capacity factor, or operable ratio of power generation to capacity for the generator to operate\ncf_hist Float64 E4ST.MWhGeneratedPerMWhCapacity false The historical capacity factor for the generator, or the gentype if no previous data is available. Primarily used to calculate estimate policy value (PTC and EmissionPrice capex_adj)\naf Float64 E4ST.MWhGeneratedPerMWhCapacity false The availability factor, or maximum available ratio of pewer generation to nameplate capacity for the generator.\nemis_co2 Float64 E4ST.ShortTonsPerMWhGenerated false The emission rate per MWh of CO2\ncapt_co2_percent Float64 E4ST.NA false The percentage of co2 emissions captured, to be sequestered.\nheat_rate Float64 E4ST.MMBtuPerMWhGenerated false Heat rate, or MMBtu of fuel consumed per MWh electricity generated (0 for generators that don't use combustion)\nchp_co2_multi Float64 E4ST.NA false The percentage of CO2 emissions from CHP attributed to the power generation. Used to calculate CO2e\nreg_factor Float64 E4ST.NA true The percentage of generation that dispatches to a cost-of-service regulated market\n\n\n\n\n\n","category":"method"},{"location":"inputs/gen/#Buildable-Generator-Specifications","page":"Generator Table","title":"Buildable Generator Specifications","text":"","category":"section"},{"location":"inputs/gen/","page":"Generator Table","title":"Generator Table","text":"summarize_table(::Val{:build_gen})","category":"page"},{"location":"inputs/gen/#E4ST.summarize_table-Tuple{Val{:build_gen}}","page":"Generator Table","title":"E4ST.summarize_table","text":"summarize_table(::Val{:build_gen})\n\ncolumn_name data_type unit required description\narea AbstractString E4ST.NA true The area with which to filter by. I.e. \"state\". Leave blank to not filter by area.\nsubarea AbstractString E4ST.NA true The subarea to include in the filter.  I.e. \"maryland\".  Leave blank to not filter by area.\nbuild_status InlineStrings.String15 E4ST.NA true Whether the generator is built, 'new, or unbuilt. All generators marked new when the gen file is read in will be changed to built.  Can also be changed to retired_exog or retired_endog after the simulation is run.  See update_build_status!\nbuild_type AbstractString E4ST.NA true Whether the generator is 'real', 'exog' (exogenously built), or 'endog' (endogenously built). Should either be exog or endog for buil_gen.\nbuild_id AbstractString E4ST.NA true Identifier of the build row.  Each generator made using this build spec will inherit this build_id\ngenfuel AbstractString E4ST.NA true The fuel type that the generator uses. Leave blank to not filter by genfuel.\ngentype String E4ST.NA true The generation technology type that the generator uses. Leave blank to not filter by gentype.\nstatus Bool E4ST.NA false Whether or not to use this set of characteristics/specs\npcap0 Float64 E4ST.MWCapacity true Starting nameplate power generation capacity for the generator. Should be 0 for endog new gens.\npcap_min Float64 E4ST.MWCapacity true Minimum nameplate power generation capacity of the generator (normally set to zero to allow for retirement)\npcap_max Float64 E4ST.MWCapacity true Maximum nameplate power generation capacity of the generator\nvom Float64 E4ST.DollarsPerMWhGenerated true Variable operation and maintenance cost per MWh of generation\nfuel_price Float64 E4ST.DollarsPerMMBtu false Fuel cost per MMBtu of fuel used.  heat_rate column also necessary when supplying fuel_price\nfom Float64 E4ST.DollarsPerMWCapacityPerHour true Hourly fixed operation and maintenance cost for a MW of generation capacity\ncapex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for a MW of generation capacity\ntransmission_capex Float64 E4ST.DollarsPerMWBuiltCapacityPerHour true Hourly capital expenditures for the transmission supporting a MW of generation capacity\nroutine_capex Float64 E4ST.DollarsPerMWCapacityPerHour true Routing capital expenditures for a MW of discharge capacity\ncf_min Float64 E4ST.MWhGeneratedPerMWhCapacity false The minimum capacity factor, or operable ratio of power generation to capacity for the generator to operate.  Take care to ensure this is not above the hourly availability factor in any of the hours, or else the model may be infeasible.  Set to zero by default.\ncf_max Float64 E4ST.MWhGeneratedPerMWhCapacity false The maximum capacity factor, or operable ratio of power generation to capacity for the generator to operate\ncf_hist Float64 E4ST.MWhGeneratedPerMWhCapacity false The historical capacity factor for the generator or the gentype. Primarily used to calculate estimate policy value (PTC and EmissionPrice capex_adj)\nyear_on E4ST.YearString E4ST.Year true The first year of operation for the generator. (For new gens this is also the year it was built). Endogenous unbuilt generators will be left blank\necon_life Float64 E4ST.NumYears true The number of years in the economic lifetime of the generator.\nage_shutdown Float64 E4ST.NumYears true The age at which the generator is no longer operating.  I.e. if year_on = y2030 and age_shutdown = 20, then capacity will be 0 in y2040.\nyear_on_min E4ST.YearString E4ST.Year true The first year in which a generator can be built/come online (inclusive). Generators with no restriction and exogenously built gens will be left blank\nyear_on_max E4ST.YearString E4ST.Year true The last year in which a generator can be built/come online (inclusive). Generators with no restriction and exogenously built gens will be left blank\nemis_co2 Float64 E4ST.ShortTonsPerMWhGenerated false The CO2 emission rate of the generator, in short tons per MWh generated.  This is the net emissions. (i.e. not including captured CO2 that gets captured)\ncapt_co2_percent Float64 E4ST.NA false The percentage of co2 emissions captured, to be sequestered.\n\n\n\n\n\n","category":"method"},{"location":"model/dcopf/#DC-OPF-Setup","page":"DC Optimal Power Flow","title":"DC OPF Setup","text":"","category":"section"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The E4ST.jl DC OPF is set up as a cost minimization problem. Costs are added to the objective function and benefits are subtracted. setupdcopf!() adds VOM, Fuel Cost, FOM, Capex, and Curtialment Cost to the objective function. Other terms can be added to the objective in Modifications before the model is optimized. A dictionary of the terms added to the objective function can be found in data[:objvars]. ","category":"page"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Constraints and expressions can also be defined outside of setup_dcopf!() before the model is optimized. This will also be done in Modifications. ","category":"page"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"setup_dcopf!","category":"page"},{"location":"model/dcopf/#E4ST.setup_dcopf!","page":"DC Optimal Power Flow","title":"E4ST.setup_dcopf!","text":"setup_dcopf!(config, data, model)\n\nSet up a DC OPF problem\n\n\n\n\n\n","category":"function"},{"location":"model/dcopf/#Get-Model-Variable-Function","page":"DC Optimal Power Flow","title":"Get Model Variable Function","text":"","category":"section"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"These functions get or use model variables. To get the value after optimizing the model they must be wrapped in value.(). ","category":"page"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"get_pgen_bus\nget_pflow_bus\nget_pflow_branch","category":"page"},{"location":"model/dcopf/#E4ST.get_pgen_bus","page":"DC Optimal Power Flow","title":"E4ST.get_pgen_bus","text":"get_pgen_bus(data, model, bus_idx, year_idx, hour_idx)\n\nReturns total power generation for a bus at a time     * To use this to retieve the variable values after the model has been optimized, wrap the function with value() like this: value.(getpgenbus).\n\n\n\n\n\n","category":"function"},{"location":"model/dcopf/#E4ST.get_pflow_bus","page":"DC Optimal Power Flow","title":"E4ST.get_pflow_bus","text":"get_pflow_bus(data, model, f_bus_idx, year_idx, hour_idx)\n\nReturns net power flow out of the bus\n\nTo use this to retieve the variable values after the model has been optimized, wrap the function with value() like this: value.(getpflowbus).\n\n\n\n\n\n","category":"function"},{"location":"model/dcopf/#E4ST.get_pflow_branch","page":"DC Optimal Power Flow","title":"E4ST.get_pflow_branch","text":"get_pflow_branch(data, model, branch_idx, year_idx, hour_idx)\n\nReturn total power flow on a branch. \n\nIf branchidxsigned is positive then positive power flow is in the direction fbus -> tbus listed in the branch table. It is measuring the power flow out of f_bus.\nIf branchidxsigned is negative then positive power flow is in the opposite direction, tbus -> fbus listed in the branch table. It is measuring the power flow out of t_bus. \nTo use this to retieve the variable values after the model has been optimized, wrap the function with value() like this: value.(getpflowbranch).\n\n\n\n\n\n","category":"function"},{"location":"model/dcopf/#Constriant/Expression-Info-Function","page":"DC Optimal Power Flow","title":"Constriant/Expression Info Function","text":"","category":"section"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"These functions are used in defining the model constraints. ","category":"page"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"get_pgen_max\nget_egen_gen","category":"page"},{"location":"model/dcopf/#E4ST.get_egen_gen","page":"DC Optimal Power Flow","title":"E4ST.get_egen_gen","text":"get_egen_gen(data, model, gen_idx)\n\nReturns the total energy generation from a gen summed over all rep time. \n\nget_egen_gen(data, model, gen_idx, year_idx)\n\nReturns the total energy generation from a gen summed over rep time for the given year. \n\nget_egen_gen(data, model, gen_idx, year_idx, hour_idx)\n\nReturns the total energy generation from a gen for the given year and hour.  This is pgengen multiplied by the number of hours spent at that representative hour.  See [`gethour_weight`](@ref) \n\nTo use this to retieve the variable values after the model has been optimized, wrap the function with value() like this: value.(get_egen_gen(args...)).\n\n\n\n\n\n","category":"function"},{"location":"model/dcopf/#Model-Mutation-Functions","page":"DC Optimal Power Flow","title":"Model Mutation Functions","text":"","category":"section"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"These functions are used to modify the model, specifically creating and adding terms to the objective expression. The Term abstract type is used to determine how the term (cost or benefit) should be added to the objective function.","category":"page"},{"location":"model/dcopf/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Term\nPerMWhGen\nPerMWCap\nPerMWhCurtailed\nPerMWCapInv\nadd_obj_term!\nadd_obj_exp!","category":"page"},{"location":"model/dcopf/#E4ST.Term","page":"DC Optimal Power Flow","title":"E4ST.Term","text":"abstract type Term\n\nAbstract type Term is used to add variables (terms) to the objective function or other functions. Subtypes include PerMWhGen, PerMWCap, and PerMWhCurtailed. \n\n\n\n\n\n","category":"type"},{"location":"model/dcopf/#E4ST.add_obj_term!","page":"DC Optimal Power Flow","title":"E4ST.add_obj_term!","text":"add_obj_term!(data, model, ::Term, s::Symbol; oper)\n\nAdds or subtracts cost/revenue s to the objective function of the model based on the operator oper. Adds the cost/revenue to the objective variables list in data. \n\n\n\n\n\n","category":"function"},{"location":"model/dcopf/#E4ST.add_obj_exp!","page":"DC Optimal Power Flow","title":"E4ST.add_obj_exp!","text":"function add_obj_exp!(data, model, term::Term, s::Symbol; oper)\n\nAdds expression s (already defined in model) to the objective expression model[:obj].  Adds the name, oper, and type of the term to data[:obj_vars].\n\n\n\n\n\n","category":"function"},{"location":"model/formulation/#Model-Formulation","page":"Model Formulation","title":"Model Formulation","text":"","category":"section"},{"location":"model/formulation/","page":"Model Formulation","title":"Model Formulation","text":"setup_model(config, data)","category":"page"},{"location":"model/formulation/#E4ST.setup_model-Tuple{Any, Any}","page":"Model Formulation","title":"E4ST.setup_model","text":"setup_model(config, data) -> model\n\nSets up a JuMP Model for E4ST using config and data.\n\nParameters\n\nName Symbol Letter\nN_G :num_gen Number of generators\nN_B :num_bus Number of buses\nN_L :num_branch Number of branches\nG = 12N_G  N/A Set of generator indices\nB = 12N_B  N/A Set of bus indices\nL = 12N_L  N/A Set of branch indices\ng in G :gen_idx Generator index\nb in B :bus_idx Bus index\nl in L :branch_idx Branch index\ny in Y :year_idx Year index\ny_S_g in Y :yearonidx Starting Year index for generator g\n\nVariables\n\nThese are the decision variables to be optimized over.  Can be accessed by model[symbol]\n\nName Symbol Unit Description\ntheta_byh :θ_bus Radians Hourly voltage angle of each bus. Reference buses fixed to 0.0\nP_G_gyh :pgen_gen MW Hourly avg. power generated by each generator\nP_C_gy :pcap_gen MW Annual power generation capacity of each generator\nP_S_byh :plserv_bus MW Hourly avg. power served to each bus\n\nExpressions\n\nExpressions are calculated as linear combinations of variables.  Can be accessed by model[symbol]\n\nName Symbol Unit Description\nP_F_lyh :pflow_branch MW Hourly avg. power flowing through each branch\nP_F_byh :pflow_bus MW Hourly avg. net power flowing out of each bus\nP_U_byh :plcurt_bus MW Hourly avg. power curtailed at each bus\nP_G_byh :pgen_bus MW Hourly avg. power generated at each bus\n\nConstraints\n\nName Constraint Symbol Unit Description\nC_PB_byh P_G_byh - P_S_byh = P_F_byh :cons_pbal MW Constrain the power flow at each bus\nC_PG_gyh^textmin P_G_gyh geq P_C_by^textmin :cons_pgen_min MW Constrain the generated power to be above minimum capacity factor, if given.\nC_PG_gyh^textmax P_G_gyh leq P_C_by^textmax :cons_pgen_max MW Constrain the generated power to be below min(availability factor, max capacity factor)\nC_PS_gyh^textmin P_S_byh geq 0 :cons_plserv_min MW Constrain the served power to be greater than zero\nC_PS_gyh^textmax P_S_byh leq P_D_byh :cons_plserv_max MW Constrain the served power to be less than or equal to load power.\nC_PC_gy^textmin P_C_gy geq P_C_gy^textmin :cons_pcap_min MW Constrain the power generation capacity to be less than or equal to its minimum.\nC_PC_g^textmax P_C_gy leq P_C_gy^textmaxquad forall y = y_S_g :cons_pcap_max MW Constrain the power generation capacity to be less than or equal to its minimum for its starting year.\nC_PL_lyh^+ P_F_lyh leq P_L_lyh^textmax :cons_branch_pflow_pos MW Constrain the branch power flow to be less than or equal to its maximum.\nC_PL_lyh^- -P_F_lyh leq P_L_lyh^textmax :cons_branch_pflow_neg MW Constrain the negative branch power flow to be less than or equal to its maximum.\nC_PCGPB_gy P_C_gy = 0 quad forall left yy_S_g right :cons_pcap_gen_prebuild MW Constrain the power generation capacity to be zero before the start year.\nC_PCGNA_gy P_C_gy+1 = P_C_gy quad forall left y = y_S_g right :cons_pcap_gen_noadd MW Constrain the power generation capacity to be non-increasing after the start year. Generation capacity is only added when building new generators in their start year.\nC_PCGE_gy P_C_gy == P_C_0_g quad forall left first y = y_S_g right :cons_pcap_gen_exog MW Constrain unbuilt exogenous generators to be built to pcap0 in the first year after year_on.\n\nObjective\n\nThe objective is a single expression that can be accessed via model[:obj].  In general, we add things to the objective via:\n\nadd_obj_exp!\nadd_obj_term!\n\n\n\n\n\n","category":"method"},{"location":"results/formulas/#Results-Formulas","page":"Formulas","title":"Results Formulas","text":"","category":"section"},{"location":"results/formulas/","page":"Formulas","title":"Formulas","text":"E4ST.jl produces a lot of data to comb through.  There are often some complex calculations for welfare that we may want to compute in different ways over different regions without necessarily storing every possible combination of every calculation.  The goal of the results formula is to give E4ST a way to calculate different results so that they can be calculated quickly on demand rather than always be calculated for every run.  It also provides a way to specify custom result calculations that might not be standard to E4ST.","category":"page"},{"location":"results/formulas/","page":"Formulas","title":"Formulas","text":"setup_results_formulas!\nsummarize_table(::Val{:results_formulas})\nfilter_results_formulas!\nadd_results_formula!\nget_results_formulas\nget_results_formula\ncompute_result\nResultsFormula","category":"page"},{"location":"results/formulas/#E4ST.setup_results_formulas!","page":"Formulas","title":"E4ST.setup_results_formulas!","text":"setup_results_formulas!(config, data)\n\nSets up the results formulas from config[:results_formulas_file], if provided, or loads a default set of formulas.  See summarize_table(::Val{:results_formulas}).\n\n\n\n\n\n","category":"function"},{"location":"results/formulas/#E4ST.summarize_table-Tuple{Val{:results_formulas}}","page":"Formulas","title":"E4ST.summarize_table","text":"summarize_table(::Val{:results_formulas})\n\ncolumn_name data_type unit required description\ntable_name Symbol E4ST.NA true The name of the table that the result is for.\nresult_name Symbol E4ST.NA true The name of the result that the formula is for.\nformula String E4ST.NA true The string representing the formula for the table.  See add_results_formula! for more info on this.\nunit Type{<:E4ST.Unit} E4ST.NA true The unit for the result.\ndescription String E4ST.NA true A description of the result.\n\n\n\n\n\n","category":"method"},{"location":"results/formulas/#E4ST.filter_results_formulas!","page":"Formulas","title":"E4ST.filter_results_formulas!","text":"filter_results_formulas!(data)\n\nFilters any results formulas that depend on columns that do not exist.\n\n\n\n\n\n","category":"function"},{"location":"results/formulas/#E4ST.add_results_formula!","page":"Formulas","title":"E4ST.add_results_formula!","text":"add_results_formula!(data, table_name::Symbol, result_name::Symbol, formula::String, unit::Type{<:Unit}, description::String)\n\nAdds a formula that can be used to compute results.  See compute_result.  This is also used by AggregationTemplate and YearlyTable.\n\nArguments:\n\ndata\ntable_name - the name of the table that the result is calculated from, either directly or as a combination of other results\nresult_name - the name of the result being calculated.  Cannot be a column name within the table.\nformula - formula can take two different forms.\nit can be a combination of columns to be aggregated directly from table_name.  I.e. \"SumHourly(vom, egen)\". See Sum, SumHourly, SumYearly, AverageYearly, MinHourly.\nit can also be a combination of other results. I.e. \"(vom_cost + fuel_cost) / egen_total\".\nunit - the Unit of the resulting number\ndescription - a short description of the calculation.\n\n\n\n\n\n","category":"function"},{"location":"results/formulas/#E4ST.get_results_formulas","page":"Formulas","title":"E4ST.get_results_formulas","text":"get_results_formulas(data)\n\nReturns a dictionary mapping (table_name, result_name) to ResultsFormula.\n\nget_results_formulas(data, table_name)\n\nReturns only the results formulas corresponding to table table_name.\n\n\n\n\n\n","category":"function"},{"location":"results/formulas/#E4ST.get_results_formula","page":"Formulas","title":"E4ST.get_results_formula","text":"get_results_formula(data, table_name, result_name) -> rf::ResultsFormula\n\n\n\n\n\n","category":"function"},{"location":"results/formulas/#E4ST.compute_result","page":"Formulas","title":"E4ST.compute_result","text":"compute_result(data, table_name, result_name, idxs=(:), yr_idxs=(:), hr_idxs=(:))\n\nComputes result result_name for table table_name for table indexes idxs, year indexes yr_idxs and hour indexes hr_idxs.  See add_results_formula! to add other results formulas for computing results.\n\nNote that this will recursively compute results for any derived result, as needed.\n\n\n\n\n\n","category":"function"},{"location":"results/formulas/#E4ST.ResultsFormula","page":"Formulas","title":"E4ST.ResultsFormula","text":"struct ResultsFormula\n\nThis is a type used to store a formula for computing a result.\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#Result-Aggregation-Functions","page":"Formulas","title":"Result Aggregation Functions","text":"","category":"section"},{"location":"results/formulas/","page":"Formulas","title":"Formulas","text":"Sum\nSumYearly\nAverageYearly\nMinYearly\nMaxYearly\nSumHourly\nSumHourlyWeighted\nAverageHourly\nMinHourly\nMaxHourly\nCostOfServiceRebate","category":"page"},{"location":"results/formulas/#E4ST.Sum","page":"Formulas","title":"E4ST.Sum","text":"Sum(cols...) <: Function\n\nFunction used in results formulas.  Computes the sum of the product of the column for each index in idxs\n\nsum_i in textidxs prod_c in textcols texttablei c\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.SumYearly","page":"Formulas","title":"E4ST.SumYearly","text":"SumYearly(cols...) <: Function\n\nFunction used in results formulas.  This is a function that adds up the product of each of the values given to it for each year given.\n\nsum_i in textidxs sum_y in textyr_idxs prod_c in textcols texttablei cy\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.AverageYearly","page":"Formulas","title":"E4ST.AverageYearly","text":"AverageYearly(cols...) <: Function\n\nFunction used in results formulas.  Computes the sum of the products of the columns for each index in idxs for each year, divided by the number of years.\n\nfracsum_i in textidxs sum_y in textyr_idxs prod_c in textcols texttablei cytextlength(yr_idxs)\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.MinYearly","page":"Formulas","title":"E4ST.MinYearly","text":"MinYearly(cols...) <: Function\n\nThis function returns the minimum yearly value.\n\nmin_y in textyr_idxs sum_i in textidxs h in texthr_idxs prod_c in textcols texttablei cy h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.MaxYearly","page":"Formulas","title":"E4ST.MaxYearly","text":"MaxYearly(cols...) <: Function\n\nThis function returns the maximum yearly value.\n\nmax_y in textyr_idxs sum_i in textidxs h in texthr_idxs prod_c in textcols texttablei cy h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.SumHourly","page":"Formulas","title":"E4ST.SumHourly","text":"SumHourly(cols...) <: Function\n\nThis is a function that adds up the product of each of the values given to it for each of the years and hours given.\n\nsum_i in textidxs sum_y in textyr_idxs sum_h in texthr_idxs prod_c in textcols texttablei cy h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.SumHourlyWeighted","page":"Formulas","title":"E4ST.SumHourlyWeighted","text":"SumHourlyWeighted(cols...) <: Function\n\nThis is a function that adds up the product of each of the values given to it times the hour weight for each of the years and hours given.\n\nsum_i in textidxs sum_y in textyr_idxs sum_h in texthr_idxs w_h prod_c in textcols texttablei cy h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.AverageHourly","page":"Formulas","title":"E4ST.AverageHourly","text":"AverageHourly(cols...) <: Function\n\nFunction used in results formulas.  Computes the sum of the products of the columns for each index in idxs for each year and hour, divided by the number of hours.\n\nfracsum_i in textidxs sum_y in textyr_idxs prod_c in textcols texttablei cysum_y in textyr_idxs h in texthr_idxs w_h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.MinHourly","page":"Formulas","title":"E4ST.MinHourly","text":"MinHourly(cols...) <: Function\n\nThis function returns the minimum hourly value.\n\nmin_y in textyr_idxs h in texthr_idxs sum_i in textidxs prod_c in textcols texttablei cy h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.MaxHourly","page":"Formulas","title":"E4ST.MaxHourly","text":"MaxHourly(cols...) <: Function\n\nThis function returns the maximum hourly value.\n\nmax_y in textyr_idxs h in texthr_idxs sum_i in textidxs prod_c in textcols texttablei cy h\n\n\n\n\n\n","category":"type"},{"location":"results/formulas/#E4ST.CostOfServiceRebate","page":"Formulas","title":"E4ST.CostOfServiceRebate","text":"CostOfServiceRebate(table_name) <: Function\n\nThis is a special function that computes the sum of the net total revenue times the regulatory factor reg_factor.  This only works for the gen table and storage table.\n\n\n\n\n\n","category":"type"},{"location":"types/container/#Container","page":"Container","title":"Container","text":"","category":"section"},{"location":"types/container/","page":"Container","title":"Container","text":"Container\nByNothing\nByYear\nByHour\nByYearAndHour\nto_container\nto_container!","category":"page"},{"location":"types/container/#E4ST.Container","page":"Container","title":"E4ST.Container","text":"abstract type Container\n\nAbstract type for containers that can be indexed by year and time.  i.e. c[yr_idx, hr_idx] will work, even if c contains a single number, a number for each year, a number for each hour, or a number for each year and hour.\n\n\n\n\n\n","category":"type"},{"location":"types/container/#E4ST.to_container","page":"Container","title":"E4ST.to_container","text":"to_container(v) -> cv::Vector{Container}\n\nConverts v to a Vector{Container}\n\n\n\n\n\n","category":"function"},{"location":"types/container/#E4ST.to_container!","page":"Container","title":"E4ST.to_container!","text":"to_container!(table, col_name)\n\nConverts table[!, :col_name] to a Vector{Container}.\n\n\n\n\n\n","category":"function"},{"location":"types/modifications/fuel-price/#Fuel-Price","page":"Endogenous Fuel Prices","title":"Fuel Price","text":"","category":"section"},{"location":"types/modifications/fuel-price/","page":"Endogenous Fuel Prices","title":"Endogenous Fuel Prices","text":"FuelPrice\nmodify_raw_data!(mod::FuelPrice, config, data)\nmodify_setup_data!(mod::FuelPrice, config, data)\nmodify_model!(mod::FuelPrice, config, data, model)\nmodify_results!(mod::FuelPrice, config, data)\nsummarize_table(::Val{:fuel_price})","category":"page"},{"location":"types/modifications/fuel-price/#E4ST.FuelPrice","page":"Endogenous Fuel Prices","title":"E4ST.FuelPrice","text":"FuelPrice(;file) <: Modification\n\nFuelPrice is a Modification allowing users to specify fuel prices for different fuels by region.  If multiple steps and quantities are given, the fuel price for a given region will be computed endogenously.\n\nmodify_raw_data!(mod::FuelPrice, config, data)\nmodify_setup_data!(mod::FuelPrice, config, data)\nmodify_model!(mod::FuelPrice, config, data, model)\nmodify_results!(mod::FuelPrice, config, data)\n\nTo adjust price by hour or year, see AdjustHourly or AdjustYearly.\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/fuel-price/#E4ST.modify_raw_data!-Tuple{FuelPrice, Any, Any}","page":"Endogenous Fuel Prices","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(mod::FuelPrice, config, data)\n\nRead table from mod.file into data[:fuel_price]\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/fuel-price/#E4ST.modify_setup_data!-Tuple{FuelPrice, Any, Any}","page":"Endogenous Fuel Prices","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(mod::FuelPrice, config, data)\n\nZero out the fuel_price column of the gen table, as it will get overwritten later by this Modification.  This is to avoid double-counting the fuel cost.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/fuel-price/#E4ST.modify_model!-Tuple{FuelPrice, Any, Any, Any}","page":"Endogenous Fuel Prices","title":"E4ST.modify_model!","text":"modify_model!(mod::FuelPrice, config, data, model)\n\nMake data[:fuel_markets] to keep track of each of the fuel markets\nAdd variable fuel_sold[fuel_price_idx,  yr_idx, hr_idx]: total fuel sold at each price step for each time interval\nAdd expression fuel_used[fuel_market_idx, yr_idx, hr_idx]: total fuel used by generators for each market region for each time interval\nAdd expression fuel_price_obj[fuel_market_idx, yr_idx, hr_idx]: total cost of the fuel, added to the objective.\nAdd constraint cons_fuel_sold[fuel_price_idx, yr_idx]: constrain the total fuel_sold in each year to be ≤ yearly quantity\nAdd constraint cons_fuel_bal[fuel_market_idx, yr_idx, hr_idx]: constrain the amount of fuel sold in each market region to equal the amount of fuel used in each market region.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/fuel-price/#E4ST.modify_results!-Tuple{FuelPrice, Any, Any}","page":"Endogenous Fuel Prices","title":"E4ST.modify_results!","text":"modify_results!(mod::FuelPrice, config, data)\n\nCalculate the clearing price for each market region for each fuel type.\nEqual to the shadow price of cons_fuel_sold for the cheapest fuel price step in the region plus the cheapest fuel price\nAdd it to fuel_markets.clearing_price column\nUpdate gen.fuel_price column to use the clearing price (multiplied by the heat_rate column)\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/fuel-price/#E4ST.summarize_table-Tuple{Val{:fuel_price}}","page":"Endogenous Fuel Prices","title":"E4ST.summarize_table","text":"summarize_table(::Val{:fuel_price})\n\ncolumn_name data_type unit required description\ngenfuel String E4ST.NA true The type of fuel that the price applies for. i.e. ng or coal\narea String E4ST.NA true The area that the price applies for i.e. nation.  Leave blank if grid-wide\nsubarea String E4ST.NA true The subarea that the price applies for i.e. narnia.  Leave blank if grid-wide\nfilter_ String E4ST.NA false I.e. filter1, filter2, etc. Other filter conditions that the price applies for, see parse_comparison for ideas\nprice Float64 E4ST.DollarsPerMMBtu true The price of 1 MMBtu of fuel\nquantity Float64 E4ST.MMBtu true The number of MMBtu of the fuel available at the price in each year.  Set to Inf for unlimited.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/retrofits/#Retrofits","page":"Retrofits","title":"Retrofits","text":"","category":"section"},{"location":"types/modifications/retrofits/","page":"Retrofits","title":"Retrofits","text":"Retrofit\nmodify_setup_data!(ret::Retrofit, config, data)\nmodify_model!(ret::Retrofit, config, data, model)\ninit!(ret::Retrofit, config, data)\ncan_retrofit\nretrofit!","category":"page"},{"location":"types/modifications/retrofits/#E4ST.Retrofit","page":"Retrofits","title":"E4ST.Retrofit","text":"Retrofit <: Modification\n\nAbstract supertype for retrofits.  Must implement the following interfaces:\n\n(required) can_retrofit(ret::Retrofit, gen::DataFrameRow)-> ::Bool - returns whether or not a generator row can be retrofitted.\n(required) retrofit!(ret::Retrofit, gen)-> newgen::AbstractDict - returns a new row to be added to the gen table.\n(optional) init!(ret::Retrofit, config, data) - initialize data with the Retrofit by adding any necessary columns to the gen table, etc.  Defaults to do nothing.\n\nThe following methods are defined for Retrofit, so you do not define any of the ordinary Modification methods for any subtype of Retrofit - only implement the above interfaces.\n\nmodify_setup_data!(ret::Retrofit, config, data)\nmodify_model!(ret::Retrofit, config, data, model)\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/retrofits/#E4ST.modify_setup_data!-Tuple{Retrofit, Any, Any}","page":"Retrofits","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(ret::Retrofit, config, data)\n\nCalls init!(ret::Retrofit, config, data) to initialize the data.\nMakes a Dict in data[:retrofits] to keep track of the retrofits being produced for each retrofit.\nLoops through the rows of the gen table\nChecks to see if the can be retrofitted via can_retrofit(ret::Retrofit, row)\nConstructs the new retrofitted generator via retrofit!(ret::Retrofit, row)\nConstructs one new one for each year in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/retrofits/#E4ST.modify_model!-Tuple{Retrofit, Any, Any, Any}","page":"Retrofits","title":"E4ST.modify_model!","text":"modify_model!(ret::Retrofit, config, data, model)\n\nModifies the model for retrofits.  Only happens once, for all retrofits.\n\nConstrains the sum of the capacities of the original generators and the retrofits is less than the original max and greater than the original min by adding constraints cons_pcap_gen_retro_min and cons_pcap_gen_retro_max\nRemoves the cons_pcap_gen_noadd constraints for prior to and on the retrofit year.\nFix the capacity of the new retrofit generators to 0 before the retrofit year.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/retrofits/#E4ST.init!-Tuple{Retrofit, Any, Any}","page":"Retrofits","title":"E4ST.init!","text":"init!(ret::Retrofit, config, data)\n\ninitialize data with the Retrofit by adding any necessary columns to the gen table, etc.  Defaults to do nothing.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/retrofits/#E4ST.can_retrofit","page":"Retrofits","title":"E4ST.can_retrofit","text":"can_retrofit(ret::Retrofit, row) -> ::Bool\n\nReturns whether or not a generator row can be retrofitted.\n\n\n\n\n\n","category":"function"},{"location":"types/modifications/retrofits/#E4ST.retrofit!","page":"Retrofits","title":"E4ST.retrofit!","text":"retrofit!(ret::Retrofit, newgen) -> ::AbstractDict\n\nRetrofits newgen, a Dict containing all the properties of the original generator, but with the year_retrofit already updated.  Note that the capex should be included in the retrofitted generator WITHOUT the existing generator's capex.  I.e. capex for the retrofit should be only the capital costs for the retrofit, not including the initial capital costs for building the generator.\n\n\n\n\n\n","category":"function"},{"location":"types/modifications/retrofits/#Coal-CCS-Retrofit","page":"Retrofits","title":"Coal CCS Retrofit","text":"","category":"section"},{"location":"types/modifications/retrofits/","page":"Retrofits","title":"Retrofits","text":"CoalCCSRetrofit","category":"page"},{"location":"types/modifications/retrofits/#E4ST.CoalCCSRetrofit","page":"Retrofits","title":"E4ST.CoalCCSRetrofit","text":"CoalCCSRetrofit(;kwargs...) <: Retrofit\n\nCoalCCSRetrofit represents a Retrofit for changing coal-burning plants (gentype=\"coal\"), to have carbon capture technology, and be changed to (gentype=\"coalccsusretrofit\")\n\nKeyword Arguments:\n\ncrf = 0.115642438 - the capital recovery factor (default value assumes 12 year economic lifetime)\ncapt_co2_percent = 0.9 - (between 0 and 1) the percentage of CO₂ captured by the retrofit\nreduce_nox_percent =  0.25 - (between 0 and 1) the percent reduction in NOₓ emissions (default is midpoint of 0% and 50% reduction)\nreduce_so2_percent = 0.985 - (between 0 and 1) the percent reduction in SO₂ emissions (default is midpoint of 97% and 100% reduction)\nreduce_pm25_percent = 0.33 - (between 0 and 1) the percent reduction in PM2.5 emissions (default is midpoint of -4% and 70% reduction)\necon_life = 12.0 - the assumed economic life of the retrofit.  Moves out the planned yearshutdown to be at the end of the retrofit economic lifetime if yearshutdown is earlier than the end of the econ life.\n\nOther Requirements:\n\nThe gen table must have a heat_rate column\nThe gen table must either have a pcap_plant_avg column, or it will be assumed that each generator represents a single plant.  This value is used with the cost curves.\n\nCost adjustment values come from a regression in EPA Schedule 6 data.\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/ccus/#CO-Capture,-Utilization-and-Storage","page":"CO₂ Capture, Utilization & Storage","title":"CO₂ Capture, Utilization & Storage","text":"","category":"section"},{"location":"types/modifications/ccus/","page":"CO₂ Capture, Utilization & Storage","title":"CO₂ Capture, Utilization & Storage","text":"CCUS\nmodify_raw_data!(::CCUS, config, data)\nmodify_setup_data!(::CCUS, config, data)\nmodify_model!(::CCUS, config, data, model)\nmodify_results!(::CCUS, config, data)\nsummarize_table(::Val{:ccus_paths})","category":"page"},{"location":"types/modifications/ccus/#E4ST.CCUS","page":"CO₂ Capture, Utilization & Storage","title":"E4ST.CCUS","text":"struct CCUS <: Modification\n\nCCUS(;file, groupby, co2_scalar=1e5, co2_step_quantity_limit=1e9)\n\nThis is a Modification that sets up markets for carbon captured by generators.  \n\nfile - a file to the table containing markets/prices for buying/selling carbon dioxide.  See the ccus_paths table below, or summarize_table(::Val{:ccus_paths})\ngroupby - a String indicating how markets are grouped.  I.e. \"state\".\nco2_scalar - a Float64 for how much to scale the co2 variables by.  This helps with numerical instability, given that some CO₂ steps can be very large and could bloat the RHS and bounds range of the model.  A good rule of thumb is that this should be no less than 1e4 times smaller than co2_step_quantity_limit.\nco2_step_quantity_limit - A Float64 for the maximum quantity of CO₂ that can be stored in any step.\n\nCreates the following tables in data:\n\nccus_paths - contains all pathways possible to sell CO₂.  \nproducing_region - The producing region\nstoring_region - The storing region of the pathway\nccus_type - the type of ccus (eor or saline)\nstep_id - the number of the step (not very important other than for book-keeping)\nstep_quantity - the quantity of CO₂ that can be stored in this step\nprice_trans - the cost to transport 1 short ton of CO₂ from producing_region to storing_region\nprice_store - the cost to store 1 short ton of CO₂ in the step\nccus_storers - contains all the storers\nstoring_region - the storing region\nstep_id - the number of the step for the region\nccus_type - whether the step is eor or saline.\nstep_quantity - the number of short tons that may be stored in the step\nprice_store - the price to store a short ton of CO₂.\npath_idxs - A list of indices representing the transportation paths to store carbon in this step.  Indexes into ccus_paths table.\nccus_producers - contains all the producers, grouped by ccus_type and producing_region.  This contains the following columns:\nproducing_region - the region the CO₂ will be sent from\nccus_type - the type of the step the CO₂ will be sent to (eor or saline)\npath_idxs - A list of indices representing the transportation paths to send carbon from this step.  Indexes into ccus_paths table.\ngen_idxs - A list of generator indices that produce CO₂ in this region.\n\nCreates the following variables/expressions\n\nco2_trans[1:nrow(ccus_paths), 1:nyear] - the amount of CO₂ transported along this producer-producer pathway (variable)\nco2_stor[1:nrow(ccus_storers), 1:nyear] - the amount of CO₂ stored by each storer (expression of co2_trans)\nco2_prod[1:nrow(ccus_producers), 1:nyear] - the amount of CO₂ produced by each sending region (expression of electricity generation)\nco2_sent[1:nrow(ccus_producers), 1:nyear] - the amount of CO₂ sent out from each sending region (expression of co2_trans).  This includes CO₂ sent within the same region.\ncost_ccus_obj[1:nyear] - the total cost of ccus, as added to the objective function.\n\nCreates the following constraints\n\ncons_co2_stor[1:nrow(ccus_storers), 1:nyear] - the CO₂ stored at each injection site must not exceed step_quantity\ncons_co2_bal[1:nrow(ccus_producers), 1:nyear] - the CO₂ balancing equation for each region, i.e. co2_prod == co2_sent.\n\nAccessing Results\n\nResults are stored in 2 places; the ccus_paths table, and the gen table.\n\nExample Result Queries\n\ncompute_result(data, :gen, :stored_co2_total, :ccus_type=>\"eor\", \"y2030\")\ncompute_result(data, :gen, :cost_capt_co2, :ccus_type=>\"eor\", yr_idx)\ncompute_result(data, :gen, :cost_capt_co2_store, :gentype=>\"coalccs\", yr_idx)\ncompute_result(data, :gen, :cost_capt_co2_trans, :, yr_idx)\n`computeresult(data, :ccuspaths, :storercosttotal, :storing_region=>\"narnia\")\ncompute_result(data, :ccus_paths, :storer_revenue_total, :producing_region=>\"narnia\")\ncompute_result(data, :ccus_paths, :storer_profit_total, :ccus_type=>\"eor\")\n\nSee also:\n\nmodify_raw_data!(::CCUS, config, data)\nmodify_setup_data!(::CCUS, config, data)\nmodify_model!(::CCUS, config, data, model)\nmodify_results!(::CCUS, config, data)\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/ccus/#E4ST.modify_raw_data!-Tuple{CCUS, Any, Any}","page":"CO₂ Capture, Utilization & Storage","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(mod::CCUS, config, data) -> nothing\n\nLoads mod.file into data[:ccus_paths].  See summarize_table(::Val{:ccus_paths}) for more info.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/ccus/#E4ST.modify_setup_data!-Tuple{CCUS, Any, Any}","page":"CO₂ Capture, Utilization & Storage","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(mod::CCUS, config, data) -> nothing\n\nDoes the following:\n\nAdds a column for carbon captured, capt_co2, based on emis_co2, and capt_co2_percent\nreduces emis_co2 by capt_co2\nSplits up carbon capturing generators into 2 separate generators - one for \"saline\" and one for \"eor\", and adjusts the eor emissions by config[eor_leakage_rate]\nAdd a column for ccus_type - either \"eor\", \"saline\", or \"na\"\nAdds sets of indices to data[:ccus_gen_sets]::Vector{Vector{Int64}}\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/ccus/#E4ST.modify_model!-Tuple{CCUS, Any, Any, Any}","page":"CO₂ Capture, Utilization & Storage","title":"E4ST.modify_model!","text":"modify_model!(mod::Modification, config, data, model)\n\nApply mod to the model, called in setup_model\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/ccus/#E4ST.modify_results!-Tuple{CCUS, Any, Any}","page":"CO₂ Capture, Utilization & Storage","title":"E4ST.modify_results!","text":"modify_results!(mod::CCUS, config, data)\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/ccus/#E4ST.summarize_table-Tuple{Val{:ccus_paths}}","page":"CO₂ Capture, Utilization & Storage","title":"E4ST.summarize_table","text":"summarize_table(::Val{:ccus_paths})\n\ncolumn_name data_type unit required description\nproducing_region String E4ST.NA true The name of the producing region (type of regions specified by groupby kwarg of CCUS mod\nstoring_region String E4ST.NA true The name of the sequestering region (type of regions specified by groupby kwarg of CCUS mod\nstep_id Int64 E4ST.NA true The number of this particular market step\nccus_type String E4ST.NA true The type of storage.  Can be \"eor\" or \"saline\"\nstep_quantity Float64 E4ST.ShortTonsPerYear true The annual quantity of CO2 that can be stored in the step\nprice_trans Float64 E4ST.DollarsPerShortTon true The cost of transporting a short ton of CO2 for this producer-storing_region pair\nprice_store Float64 E4ST.DollarsPerShortTon true The cost to store a short ton of CO2 in this storage step\n\n\n\n\n\n","category":"method"},{"location":"types/unit/#Unit","page":"Unit","title":"Unit","text":"","category":"section"},{"location":"types/unit/","page":"Unit","title":"Unit","text":"Unit","category":"page"},{"location":"types/unit/#E4ST.Unit","page":"Unit","title":"E4ST.Unit","text":"abstract type E4ST.Unit\n\nRepresents possible units for table columns in E4ST.\n\n\n\n\n\n","category":"type"},{"location":"types/unit/#Subtypes","page":"Unit","title":"Subtypes","text":"","category":"section"},{"location":"types/unit/","page":"Unit","title":"Unit","text":"using E4ST # hide\nforeach(println, E4ST.subtypes(Unit)) # hide","category":"page"},{"location":"inputs/data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"inputs/data/#Loading-Data","page":"Data","title":"Loading Data","text":"","category":"section"},{"location":"inputs/data/","page":"Data","title":"Data","text":"read_data\nread_data_files!(config, data)\nmodify_raw_data!(config, data)\nsetup_data!\nmodify_setup_data!(config, data)\nread_summary_table!\nsetup_table!(config, data, ::Symbol)","category":"page"},{"location":"inputs/data/#E4ST.read_data","page":"Data","title":"E4ST.read_data","text":"read_data(config) -> data\n\nPulls in data found in files listed in the config, and stores into data.\n\nCalls the following functions:\n\nread_data_files!(config, data) - read in the data from files\nmodify_raw_data!(config, data) - Gives Modifications a chance to modify the raw data before the data gets setup.\nsetup_data!(config, data) - Sets up the data, modifying/adding to the tables as needed.\nmodify_setup_data!(config, data) - Gives Modifications a chance to modify the setup data before the model is built.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.read_data_files!-Tuple{Any, Any}","page":"Data","title":"E4ST.read_data_files!","text":"read_data_files!(config, data)\n\nLoads in the data files presented in the config.\n\n\n\n\n\n","category":"method"},{"location":"inputs/data/#E4ST.modify_raw_data!-Tuple{Any, Any}","page":"Data","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(config, data)\n\nAllows Modifications to modify the raw data - calls modify_raw_data!(mod, config, data)\n\n\n\n\n\n","category":"method"},{"location":"inputs/data/#E4ST.setup_data!","page":"Data","title":"E4ST.setup_data!","text":"setup_data!(config, data)\n\nSets up the data, modifying, adding to, or combining the tables as needed. New generators built in the setup_gen_table! function. \n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.modify_setup_data!-Tuple{Any, Any}","page":"Data","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(config, data)\n\nAllows Modifications to modify the raw data - calls modify_setup_data!(mod, config, data)\n\n\n\n\n\n","category":"method"},{"location":"inputs/data/#E4ST.read_summary_table!","page":"Data","title":"E4ST.read_summary_table!","text":"read_summary_table!(config, data)\n\nLoads in the summary table for each of the other tables.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.setup_table!-Tuple{Any, Any, Symbol}","page":"Data","title":"E4ST.setup_table!","text":"setup_table!(config, data, table_name)\n\nSets up the data[:table_name].  Calls setup_table!(config, data, Val(table_name)), if defined.\n\n\n\n\n\n","category":"method"},{"location":"inputs/data/#Accessor-Functions","page":"Data","title":"Accessor Functions","text":"","category":"section"},{"location":"inputs/data/","page":"Data","title":"Data","text":"get_table_summary\nget_table_names\nget_table\nget_table_row_idxs\nget_table_val\nget_table_num\nget_table_col\nget_table_col_type\nget_table_col_unit\nget_table_col_description\nget_row_idxs\nget_year_idxs\nget_hour_idxs\nhas_table\nget_num\nparse_comparison\nparse_comparisons\nparse_year_idxs\nparse_hour_idxs\ncomparison","category":"page"},{"location":"inputs/data/#E4ST.get_table_summary","page":"Data","title":"E4ST.get_table_summary","text":"get_table_summary(data, table_name) -> summary::SubDataFrame\n\nReturns a summary of table_name, read in from summarize_table and read_summary_table!.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_names","page":"Data","title":"E4ST.get_table_names","text":"get_table_names(data) -> table_list\n\nReturns a list of all the tables in data.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table","page":"Data","title":"E4ST.get_table","text":"get_table(data, table_name, conditions...) -> subtable::SubDataFrame\n\nReturn a subset of the table table_name for which the row passes the conditions.  Conditions are Pairs generally consisting of <column name> => value.  Here are some examples of supported conditions:\n\n:genfuel => \"ng\" - All rows for which row.genfuel == \"ng\"\n\"bus_idx\" => 1 - All rows for which row.bus_idx == 1.  Note that the column name can be String or Symbol\n:bus_idx  => \"1\" - All rows for which row.bus_idx == 1.  Note that this is a String but it will get converted to the eltype of table.bus_idx for the comparison\n:year_on  => (\"y2022\", \"y2030\") - All rows for which row.year_on is between \"y2022\" and \"y2030\", inclusive.  Also works for fractional years.\n:genfuel => [\"ng\", \"solar\", \"wind\"] - All rows for which row.genfuel is either \"ng\", \"solar\", or \"wind\"\n:emis_co2 => f::Function - All rows for which f(row.emis_co2) returns true.  For example >(0), or x->(0<x<=0.5)\n\n\n\n\n\nget_table(data, table_name::Symbol) -> table::DataFrame\n\nRetrieves data[table_name], enforcing that it is a DataFrame.  See get_table_names for a list of available tables.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_row_idxs","page":"Data","title":"E4ST.get_table_row_idxs","text":"get_table_row_idxs(data, table_name, conditions...) -> row_idxs::Vector{Int64}\n\nGets the row indices for data[table_name] for which the conditions hold true.  See get_table for a description of possible conditions\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_val","page":"Data","title":"E4ST.get_table_val","text":"get_table_val(data, table_name, col_name, row_idx) -> val\n\nReturns the value of the table at column col_name and row row_idx\n\nRelated functions:\n\nget_table_num(data, table_name, col_name, row_idx, yr_idx, hr_idx): retrieves the Float64 from data[variable_name], indexing by year and hour.\nget_num(data, name, yr_idx, hr_idx): retrieves a Float64 from data, indexing by year and hour.\nget_val(data, variable_name): retrieves the value from data[variable_name] regardless of type, not indexed by row, year or hour.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_num","page":"Data","title":"E4ST.get_table_num","text":"get_table_num(data, table_name, col_name, row_idx, yr_idx, hr_idx) -> num::Float64\n\nRetrieves a Float64 from  table[row_idx, col_idx][yr_idx, hr_idx].  This indexes into Containers as needed and will still work for Float64 columns.\n\nRelated functions:\n\nget_table_val(data, table_name, col_name, row_idx): retrieves the raw value from the table (without indexing by year/hour).\nget_num(data, name, yr_idx, hr_idx): retrieves a Float64 from data, indexing by year and hour.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_col","page":"Data","title":"E4ST.get_table_col","text":"get_table_col(data, table_name, col_name) -> col::Vector\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_col_type","page":"Data","title":"E4ST.get_table_col_type","text":"get_table_col_type(data, table_name, column_name) -> ::Type\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_col_unit","page":"Data","title":"E4ST.get_table_col_unit","text":"get_table_col_unit(data, table_name, column_name) -> unit::Type{<:Unit}\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_table_col_description","page":"Data","title":"E4ST.get_table_col_description","text":"get_table_col_description(data, table_name, column_name) -> description\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_row_idxs","page":"Data","title":"E4ST.get_row_idxs","text":"get_row_idxs(table, conditions) -> row_idxs\n\nReturns row indices of the passed-in table that correspond to conditions, where conditions can be:\n\n::Colon - all rows\n::Int64 - a single row\n::AbstractVector{Int64} - a list of rows\np::Pair - returns a Vector containing the index of each row for which comparison(p[2], typeof(row[p[1]]))(row[p[1]]) is true.  See comparison \npairs, an iterator of Pairs - returns a Vector containing the indices which satisfy all the pairs as above.\n\nSome possible pairs to filter by:\n\n:nation => \"narnia\": checks if the nation column is equal to the string \"narnia\"\n:emis_co2 => >=(0.1): checks if the emis_co2 column is greater than or equal to 0.1\n:age => (2,10): checks if the age column is between 2, and 10, inclusive.  To be exclusive, use different values like (2.0001, 9.99999) for clarity\n:state => in((\"alabama\", \"arkansas\")): checks if the state column is either \"alabama\" or \"arkansas\"\n\nUsed in get_table and get_table_row_idxs.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_year_idxs","page":"Data","title":"E4ST.get_year_idxs","text":"get_year_idxs(data, year_idxs) -> idxs\n\nConverts year_idxs into a usable set of indices that can index into get_years(data).  year_idxs can be any of the following types:\n\nColon\nInt64\nAbstractVector{Int64}\nAbstractString - Representing the year, i.e. \"y2020\"\nAbstractVector{<:AbstractString} - a vector of strings representing the year, i.e. \"y2020\"\nTuple{<:AbstractString, <:AbstractString}\nFunction - a function of the year string that returns a boolean.  I.e. <=(\"y2030\")\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_hour_idxs","page":"Data","title":"E4ST.get_hour_idxs","text":"get_hour_idxs(data, hour_idxs)\n\nConverts hour_idxs into a usable set of indices that can index into hourly data.  hour_idxs can be any of the following types:\n\nColon\nInt64\nAbstractVector{Int64}    \n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.has_table","page":"Data","title":"E4ST.has_table","text":"has_table(data, table_name) -> Bool\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.get_num","page":"Data","title":"E4ST.get_num","text":"get_num(data, variable_name, yr_idx, hr_idx) -> num::Float64\n\nget_num(table, col_name, row_idx, yr_idx, hr_idx) -> num::Float64\n\nRetrieves a Float64 from data[variable_name], indexing by year and hour.  Works for Containers and Numbers.\n\nRelated functions:\n\nget_table_val(data, table_name, col_name, row_idx): retrieves the raw value from the table (without indexing by year/hour).\nget_table_num(data, table_name, col_name, row_idx, yr_idx, hr_idx): retrieves the Float64 from data[variable_name], indexing by year and hour.\nget_val(data, variable_name): retrieves the value from data[variable_name] regardless of type, not indexed by row, year or hour. \n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.parse_comparison","page":"Data","title":"E4ST.parse_comparison","text":"parse_comparison(table, s) -> comp\n\nParses the string, s for a comparison with which to filter table.\n\nPossible examples of strings s to parse:\n\n\"nation=>narnia\" - All rows for which row.nation==\"narnia\"\n\"bus_idx=>5\" - All rows for which row.bus_idx==5\n\"year_on=>(y2002,y2030)\" - All rows for which row.year_on is between 2002 and 2030, inclusive.\n\"emis_co2=>(0.0,4.99)\" - All rows for which row.emis_co2 is between 0.0 and 4.99, inclusive. (Works for integers and negatives too)\n\"emis_co2=> >(0)\" - All rows for which row.emis_co2 is greater than 0 (Works for integers and negatives too)\n\"year_on=> >(y2002) - All rows for which row.year_on is greater than \"y2002\" (works for fractional years too, such as \"y2002.4\")\n\"genfuel=>[ng, wind, solar]\" - All rows for which row.genfuel is \"ng\", \"wind\", or \"solar\".  Works for Ints and Floats too.\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.parse_comparisons","page":"Data","title":"E4ST.parse_comparisons","text":"parse_comparisons(row::DataFrameRow) -> pairs\n\nReturns a set of pairs to be used in filtering rows of another table.  Looks for the following properties in the row:\n\nfilter_ - if the row has any non-empty filter_ (i.e. filter1, filter2) values, it will parse the comparison via parse_comparison\ngenfuel - if the row has a non-empty genfuel, it will add an comparion that checks that each row's genfuel equals this value\ngentype - if the row has a non-empty gentype, it will add an comparion that checks that each row's gentype equals this value\nload_type - if the row has a non-empty load_type, it will add an comparion that checks that each row's load_type equals this value\n\n\n\n\n\nparse_comparisons(d::AbstractDict) -> pairs\n\nReturns a set of pairs to be used in filtering rows of another table, where each value d\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.parse_year_idxs","page":"Data","title":"E4ST.parse_year_idxs","text":"parse_year_idxs(s::AbstractString) -> comparisons\n\nParse a year comparison.  Could take the following forms:\n\n\"y2020\" - year 2020 only\n\"\" - All years, returns (:)\n\"1\" - year index 1\n\"[1,2,3]\"\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.parse_hour_idxs","page":"Data","title":"E4ST.parse_hour_idxs","text":"parse_hour_idxs(s::AbstractString) -> comparisons\n\nParse a year comparison.  Could take the following forms:\n\n\"1\" - hour 1 only\n\"\" - All hours, returns (:)\n\"season=>winter\" - returns \"season\"=>\"winter\"\n\n\n\n\n\n","category":"function"},{"location":"inputs/data/#E4ST.comparison","page":"Data","title":"E4ST.comparison","text":"comparison(value, v) -> comp::Function\n\nReturns the appropriate comparison function for value to be compared to each member of v.\n\ncomparison(value, ::Type) -> comp::Function\n\nReturns the appropriate comparison function for value to be compared to the 2nd argument type.  Here are a few options:\n\ncomparison(f::Function, ::Type) -> f\ncomparison(s::String, ::Type{<:AbstractString}) -> ==(s)\n\n\n\n\n\n","category":"function"},{"location":"develop/data_dev/#E4ST-Data-Processing-for-Development","page":"-","title":"E4ST Data Processing for Development","text":"","category":"section"},{"location":"develop/data_dev/#Adding-another-standard-data-file","page":"-","title":"Adding another standard data file","text":"","category":"section"},{"location":"develop/data_dev/","page":"-","title":"-","text":"If you'd like to add in another standard data file to be loaded into E4ST (ex: data that is required for a new standard feature of E4ST), you will need to modify the data.jl file. ","category":"page"},{"location":"develop/data_dev/","page":"-","title":"-","text":"In the data.jl file:","category":"page"},{"location":"develop/data_dev/","page":"-","title":"-","text":"Add the read_table!(config, data, :new_table_file=>:new_table) to read_data_files! (in the documentation and called in the function). \nCreate a summarize_table(::Val{:new_table}) method that mirrors the other summarize functions. This should list the columns, their type, their unit, whether they are required, and a decription of the column. This is called in read_table!\nCreate a setup_table!(config, data, ::Val{:new_table}) function. This is where you can make any changes to your data to get it into the structure needed for the DCOPF. This could include added calculated columns, putting things into containers, etc. This is not for Modifications, only standard processes that will need to happen whenever you load in that data from the csv. This can be an empty function if no setup is required. \nAdd the setup_table!(config, data, :new_table) function to setup_data! (in the documentation and called in the function).  This may be order-specific, so be careful with that.","category":"page"},{"location":"develop/data_dev/#A-note-on-adding-a-column-to-a-data-table","page":"-","title":"A note on adding a column to a data table","text":"","category":"section"},{"location":"develop/data_dev/","page":"-","title":"-","text":"The summary table contains important information about each column of each table.  There is nothing enforcing that every column must have a summary, but it is strongly advised.  It is particularly important for aggregating results, where different units get added/averaged in different ways.  To add a column to a data table, it is best to use the function add_table_col!(data, table_name, column_name, column, unit, description).","category":"page"},{"location":"types/iterable/#Iterable","page":"Iterable","title":"Iterable","text":"","category":"section"},{"location":"types/iterable/","page":"Iterable","title":"Iterable","text":"Iterable\ninit!\nissequential\nshould_iterate\niterate!\nshould_reread_data\nfieldnames_for_yaml(::Type{<:Iterable})","category":"page"},{"location":"types/iterable/#E4ST.Iterable","page":"Iterable","title":"E4ST.Iterable","text":"abstract type Iterable\n\nSometimes, it may be desirable to run E4ST back-to-back with very similar sets of inputs, changing small things in the inputs between runs.  In order to do that, we have this custom interface!\n\nThe Iterable represents how run_e4st should iterate through multiple optimizations.  This structure could be used for any number of things, such as:\n\nRunning a sequence of years\nIterating to find the optimal price for natural gas to meet some load criterion.\nRunning the first simulation for capacity/retirement, then run the next sim to find generation with a higher temporal resolution.\n\nAdding an Iterable to config\n\nAdd the Iterable to the config, in the same way as you would add a Modification to the config file.  I.e.:\n\n# Inside config.yml\niter:\n  type: MyIterType\n  myfield: myval\n\nInterfaces\n\ninit!(iter::Iterable, config) - (optional) Initialize iter with config, making any changes.\nissequential(iter) - (optional) returns whether or not the iterator will move forward in time sequentially.  Defaults to true so that the config can be reused for another simulation.\nshould_iterate(iter, config, data) - return whether or not the simulation should continue for another iteration.\niterate!(iter, config, data) - Makes any changes to any of the structures between iterations. \nshould_reread_data(iter) - Returns whether or not to reread the data when iterating. \nfieldnames_for_yaml(::Type{<:Iterable}) - (optional) return the fieldnames to print to yaml file in save_config\n\n\n\n\n\n","category":"type"},{"location":"types/iterable/#E4ST.init!","page":"Iterable","title":"E4ST.init!","text":"init!(iter, config) -> nothing\n\nInitialize iter with config, making any changes to config as needed.\n\n\n\n\n\ninit!(ret::Retrofit, config, data)\n\ninitialize data with the Retrofit by adding any necessary columns to the gen table, etc.  Defaults to do nothing.\n\n\n\n\n\ninit!(iter::RunSequential, config)\n\nSets up a new config[:out_path] by appending iter1 to config[:out_path]\n\n\n\n\n\n","category":"function"},{"location":"types/iterable/#E4ST.issequential","page":"Iterable","title":"E4ST.issequential","text":"issequential(iter) -> ::Bool\n\nReturn whether or not the iterator advances in years.  This may be necessary for some Modifications, whether they prepare the config to move forward or not.  Default is true.\n\n\n\n\n\n","category":"function"},{"location":"types/iterable/#E4ST.should_iterate","page":"Iterable","title":"E4ST.should_iterate","text":"should_iterate(iter, config, data) -> Bool\n\nReturns whether or not E4ST should iterate.\n\n\n\n\n\n","category":"function"},{"location":"types/iterable/#E4ST.iterate!","page":"Iterable","title":"E4ST.iterate!","text":"iterate!(iter::Iterable, config, data)\n\nMake any necessary modifications to the config or data based on iter.\n\n\n\n\n\n","category":"function"},{"location":"types/iterable/#E4ST.should_reread_data","page":"Iterable","title":"E4ST.should_reread_data","text":"should_reread_data(iter::Iterable) -> ::Bool\n\nReturn whether or not the data should be re-read when iterating.\n\n\n\n\n\n","category":"function"},{"location":"types/iterable/#E4ST.fieldnames_for_yaml-Tuple{Type{<:Iterable}}","page":"Iterable","title":"E4ST.fieldnames_for_yaml","text":"fieldnames_for_yaml(::Type{I}) where {I<:Iterable}\n\nreturns the fieldnames in a yaml, used for printing, modified for different types of iterables. \n\n\n\n\n\n","category":"method"},{"location":"types/iterable/#RunOnce","page":"Iterable","title":"RunOnce","text":"","category":"section"},{"location":"types/iterable/","page":"Iterable","title":"Iterable","text":"RunOnce","category":"page"},{"location":"types/iterable/#E4ST.RunOnce","page":"Iterable","title":"E4ST.RunOnce","text":"struct RunOnce <: Iterable end\n\nThis is the most basic Iterable.  It only allows E4ST to run a single time.\n\n\n\n\n\n","category":"type"},{"location":"types/iterable/#RunSequential","page":"Iterable","title":"RunSequential","text":"","category":"section"},{"location":"types/iterable/","page":"Iterable","title":"Iterable","text":"RunSequential","category":"page"},{"location":"types/iterable/#E4ST.RunSequential","page":"Iterable","title":"E4ST.RunSequential","text":"struct RunSequential <: Iterable\n\nRunSequential(;years)\n\nRuns E4ST sequentially by running years (or sets of years) one after another.  Overwrites config[:years], throwing a warning if the first set in iter is different than that in the config.\n\nyears = [\"y2020\", \"y2025\"]: this will run E4ST twice, once for each year\nyears = [\"y2020\", [\"y2025\", \"y2030\"]]: this will run E4ST twice, once for \"y2020\" and once for [\"y2025\", \"y2030\"]\n\n\n\n\n\n","category":"type"},{"location":"inputs/af/#Availability-Factor-Table","page":"Availability Factor Table","title":"Availability Factor Table","text":"","category":"section"},{"location":"inputs/af/","page":"Availability Factor Table","title":"Availability Factor Table","text":"setup_table!(config, data, ::Val{:af_table})\nsummarize_table(::Val{:af_table})","category":"page"},{"location":"inputs/af/#E4ST.setup_table!-Tuple{Any, Any, Val{:af_table}}","page":"Availability Factor Table","title":"E4ST.setup_table!","text":"setup_table!(config, data, ::Val{:af_table})\n\nPopulates the af column of the gen_table.  \n\nUpdates the generator table with the availability factors provided.  By default assigns an availability factor of 1.0 for every generator.  See summarize_table(::Val{:af_table}).\n\nOften, generators are unable to generate energy at their nameplate capacity over the course of any given representative hour.  This could depend on any number of things, such as how windy it is during a given representative hour, the time of year, the age of the generating unit, etc.  The ratio of available generation capacity to nameplate generation capacity is referred to as the availability factor (AF).\n\nThe availability factor table includes availability factors for groups of generators specified by any combination of area, genfuel, gentype, year, and hour.\n\nP_G_ghy leq f_textavail_ghy cdot P_Cgy qquad forall g in textgenerators h in texthours y in textyears \n\n\n\n\n\n","category":"method"},{"location":"inputs/af/#E4ST.summarize_table-Tuple{Val{:af_table}}","page":"Availability Factor Table","title":"E4ST.summarize_table","text":"summarize_table(::Val{:af_table})\n\ncolumn_name data_type unit required description\narea AbstractString E4ST.NA true The area with which to filter by. I.e. \"state\". Leave blank to not filter by area.\nsubarea AbstractString E4ST.NA true The subarea to include in the filter.  I.e. \"maryland\".  Leave blank to not filter by area.\ngenfuel AbstractString E4ST.NA true The fuel type that the generator uses. Leave blank to not filter by genfuel.\ngentype String E4ST.NA true The generation technology type that the generator uses. Leave blank to not filter by gentype.\nyear E4ST.YearString E4ST.Year false The year to apply the AF's to, expressed as a year string prepended with a \"y\".  I.e. \"y2022\"\nstatus Bool E4ST.NA false Whether or not to use this AF adjustment\nh_ Float64 E4ST.MWhGeneratedPerMWhCapacity true Availability factor of hour _.  Include 1 column for each hour in the hours table.  I.e. :h1, :h2, ... :hn\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/adjust/#Yearly-Adjustments","page":"Arbitrary Temporal Adjustments","title":"Yearly Adjustments","text":"","category":"section"},{"location":"types/modifications/adjust/","page":"Arbitrary Temporal Adjustments","title":"Arbitrary Temporal Adjustments","text":"AdjustYearly","category":"page"},{"location":"types/modifications/adjust/#E4ST.AdjustYearly","page":"Arbitrary Temporal Adjustments","title":"E4ST.AdjustYearly","text":"AdjustYearly(;file, name)\n\nAdjusts tables and parameters by year.  Stores the table stored in file into data[name].\n\ncolumn_name data_type unit required description\ntable_name AbstractString E4ST.NA true The name of the table to adjust.  Leave blank if this adjustment is intended for a variable in data\nvariable_name AbstractString E4ST.NA true The name of the variable/column to adjust\noperation E4ST.Operation E4ST.NA true The operation to perform.  Could be add, scale, or set.\nfilter_ String E4ST.NA true There can be multiple filter conditions - filter1, filter2, etc.  It denotes a comparison used for selecting the table rows to apply the adjustment to.  See parse_comparison for examples\nstatus Bool E4ST.NA false Whether or not to use this adjustment\ny_ Float64 E4ST.Ratio true Value to adjust by for each year.  Include a column for each year in the hours table.  I.e. :y2020, :y2030, etc\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/adjust/#Hourly-Adjustments","page":"Arbitrary Temporal Adjustments","title":"Hourly Adjustments","text":"","category":"section"},{"location":"types/modifications/adjust/","page":"Arbitrary Temporal Adjustments","title":"Arbitrary Temporal Adjustments","text":"AdjustHourly","category":"page"},{"location":"types/modifications/adjust/#E4ST.AdjustHourly","page":"Arbitrary Temporal Adjustments","title":"E4ST.AdjustHourly","text":"AdjustHourly(;file, name)\n\nAdjusts tables and parameters by hour.  Stores the table stored in file into data[name].\n\ncolumn_name data_type unit required description\ntable_name AbstractString E4ST.NA true The name of the table to adjust.  Leave blank if this adjustment is intended for a variable in data\nvariable_name AbstractString E4ST.NA true The name of the variable/column to adjust\noperation E4ST.Operation E4ST.NA true The operation to perform.  Could be add, scale, or set.\nfilter_ String E4ST.NA true There can be multiple filter conditions - filter1, filter2, etc.  It denotes a comparison used for selecting the table rows to apply the adjustment to.  See parse_comparison for examples\nyear String E4ST.Year true The year to adjust, expressed as a year string prepended with a \"y\".  I.e. \"y2022\".  Leave blank to adjust all years\nstatus Bool E4ST.NA false Whether or not to use this adjustment\nh_ Float64 E4ST.Ratio true Value to adjust by for each hour.  Include a column for each hour in the hours table.  I.e. :h1, :h2, ... :hn\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/adjust/#Adjustments-By-Age","page":"Arbitrary Temporal Adjustments","title":"Adjustments By Age","text":"","category":"section"},{"location":"types/modifications/adjust/","page":"Arbitrary Temporal Adjustments","title":"Arbitrary Temporal Adjustments","text":"AdjustByAge","category":"page"},{"location":"types/modifications/adjust/#E4ST.AdjustByAge","page":"Arbitrary Temporal Adjustments","title":"E4ST.AdjustByAge","text":"AdjustByAge(;file, name)\n\nAdjusts tables and parameters by year.  Stores the table stored in file into data[name].\n\ncolumn_name data_type unit required description\ntable_name AbstractString E4ST.NA true The name of the table to adjust.  Leave blank if this adjustment is intended for a variable in data\nvariable_name AbstractString E4ST.NA true The name of the variable/column to adjust\noperation E4ST.Operation E4ST.NA true The operation to perform.  Could be add, scale, or set.\nfilter_ String E4ST.NA true There can be multiple filter conditions - filter1, filter2, etc.  It denotes a comparison used for selecting the table rows to apply the adjustment to.  See parse_comparison for examples\nstatus Bool E4ST.NA false Whether or not to use this adjustment\nage_type String E4ST.NA true The type of age specified, can be exact, after, or trigger.  If exact, then adjustment is applied only when the age in question is between [age, age+1).  If trigger, then adjustment is applied for the first simulation year for which the age has been exceeded.  If after, then adjustment is applied on [age, Inf)\nage Float64 E4ST.NumYears true The age at which to apply this adjustment.  Applies depending on age_type\nvalue Float64 E4ST.NA true Value to adjust by.\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/dcline/#DC-Transmission-Lines","page":"DC Transmission Lines","title":"DC Transmission Lines","text":"","category":"section"},{"location":"types/modifications/dcline/","page":"DC Transmission Lines","title":"DC Transmission Lines","text":"DCLine\nmodify_raw_data!(mod::DCLine, config, data)\nmodify_model!(mod::DCLine, config, data, model)\nsummarize_table(::Val{:dc_line})","category":"page"},{"location":"types/modifications/dcline/#E4ST.DCLine","page":"DC Transmission Lines","title":"E4ST.DCLine","text":"struct DCLine <: Modification\n    \nDCLine(;file)\n\nThis Modification takes in a file representing the dc lines to add to the model.  See summarize_table(::Val{:dc_line}) for info on the table.\n\nThis creates a single variable for each dc line (at each point in time), and adds it to pbal_bus of the t_bus_idx, and subtracts it from the f_bus_idx.  Represents a lossless transfer of power, ignoring voltage angle requirements.\n\nInterfaces Implemented\n\nmodify_raw_data!(mod::DCLine, config, data) - loads mod.file => data[:dc_line]\nmodify_model!(mod::DCLine, config, data, model) - Add dc lines to the model from data[:dc_lines], creating pflow_dc variables, and adding/subtracting to the corresponding pflow_bus variables.\n\n\n\n\n\n","category":"type"},{"location":"types/modifications/dcline/#E4ST.modify_raw_data!-Tuple{DCLine, Any, Any}","page":"DC Transmission Lines","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(mod::DCLine, config, data)\n\nLoads mod.file => data[:dc_line]\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/dcline/#E4ST.modify_model!-Tuple{DCLine, Any, Any, Any}","page":"DC Transmission Lines","title":"E4ST.modify_model!","text":"modify_model!(mod::DCLine, config, data, model)\n\nAdd dc lines to the model from data[:dc_lines], creating pflow_dc variables, and adding/subtracting to the corresponding pflow_bus variables.\n\n\n\n\n\n","category":"method"},{"location":"types/modifications/dcline/#E4ST.summarize_table-Tuple{Val{:dc_line}}","page":"DC Transmission Lines","title":"E4ST.summarize_table","text":"summarize_table(::Val{:dc_line})\n\ncolumn_name data_type unit required description\nf_bus_idx Int64 E4ST.NA true The index of the bus table that the line originates from\nt_bus_idx Int64 E4ST.NA true The index of the bus table that the line goes to\nstatus Bool E4ST.NA false Whether or not the dc line is in service\npflow_max Float64 E4ST.MWFlow true Maximum power flowing through the dc line\n\n\n\n\n\n","category":"method"},{"location":"inputs/hours/#Hours-Table","page":"Hours Table","title":"Hours Table","text":"","category":"section"},{"location":"inputs/hours/","page":"Hours Table","title":"Hours Table","text":"summarize_table(::Val{:hours})\nget_hour_weights\nget_hour_weight","category":"page"},{"location":"inputs/hours/#E4ST.summarize_table-Tuple{Val{:hours}}","page":"Hours Table","title":"E4ST.summarize_table","text":"summarize_table(::Val{:hours})\n\ncolumn_name data_type unit required description\nhours Float64 E4ST.Hours true The number of hours spent in each representative hour over the course of a year (must sum to 8760)\n\n\n\n\n\n","category":"method"},{"location":"inputs/hours/#E4ST.get_hour_weights","page":"Hours Table","title":"E4ST.get_hour_weights","text":"get_hour_weights(data) -> weights\n\nget_hour_weights(data, hour_idxs) -> weights (view)\n\nReturns the number of hours in a year spent at each representative hour\n\n\n\n\n\n","category":"function"},{"location":"inputs/hours/#E4ST.get_hour_weight","page":"Hours Table","title":"E4ST.get_hour_weight","text":"get_hour_weight(data, hour_idx)\n\nReturns the number of hours in a year spent at the hour_idx representative hour\n\n\n\n\n\n","category":"function"},{"location":"results/modifications/#Results-Modifications","page":"Results Modifications","title":"Results Modifications","text":"","category":"section"},{"location":"results/modifications/","page":"Results Modifications","title":"Results Modifications","text":"AggregationTemplate\nYearlyTable","category":"page"},{"location":"results/modifications/#E4ST.AggregationTemplate","page":"Results Modifications","title":"E4ST.AggregationTemplate","text":"AggregationTemplate(;file, name) <: Modification\n\nThis is a mod that outputs aggregated results, given a file representing the template of the things to be aggregated.  name is simply the name of the modification, and will be used as the root for the filename that the aggregated information is saved to.\n\nThe file should represent a csv table with the following columns:\n\ntable_name - the name of the table being aggregated.  i.e. gen, bus, etc.\nresult_name - the name of the column in the table being aggregated.  Note that the column must have a Unit accessible via get_table_col_unit.\nfilter_ - the filtering conditions for the rows of the table. I.e. filter1.  See parse_comparisons for information on what types of filters could be provided.\nfilter_years - the filtering conditions for the years to be aggregated.  See parse_year_idxs for information on the year filters.\nfilter_hours - the filtering conditions for the hours to be aggregated.  See parse_hour_idxs for information on the hour filters.\n\n\n\n\n\n","category":"type"},{"location":"results/modifications/#E4ST.YearlyTable","page":"Results Modifications","title":"E4ST.YearlyTable","text":"struct YearlyTable <: Modification\n\nYearlyTable(;name, table_name, groupby=Symbol[], group_hours_by=Symbol[])\n\nThis modification creates an agregated table for each year in the simulation.  It includes all of the result formulas listed in get_results_formulas(data, table_name), grouped by column names in groupby.  The hours are grouped by columns from the group_hours_by field.\n\nFields:\n\nname - the name of the Modification, (don't need to specify this field in config file).  The outputed table will be saved to get_out_path(config, \"<name>_<year>.csv\")\ntable_name - the name of the table to export.  I.e. gen, bus, or branch\ngroupby = Symbol[] - the name(s) of the columns of the table specified by table_name to group by. I.e. state, nation, genfuel, gentype, etc.  Leave blank to group the whole table together into a single row.  To prevent any grouping and show every row, give a :\ngroup_hours_by = Symbol[] - the name(s) of the columns of the hours table to group by.  I.e. season.  Leave blank to group the whole table together. To prevent any grouping and show every hour, give a :\n\n\n\n\n\n","category":"type"},{"location":"results/overview/#Results-Overview","page":"Overview","title":"Results Overview","text":"","category":"section"},{"location":"results/overview/","page":"Overview","title":"Overview","text":"After optimizing the model, the following things happen:","category":"page"},{"location":"results/overview/","page":"Overview","title":"Overview","text":"parse_results! is called, gathering all values and shadow prices from the JuMP Model into data[:raw].  The model is then emptied to free up memory.  After running this, raw results can be accessed with:\nget_raw_result and get_raw_results\nresults can now be computed using compute_result\nprocess_results! is called, which in turn calls [modify_results!(mod, config, data)] for each Modification in the config.  Here are a couple of Modifications that write some handy results:\nYearlyTable\nAggregationTemplate","category":"page"},{"location":"results/overview/","page":"Overview","title":"Overview","text":"parse_results!\nprocess_results!\nparse_lmp_results!\nparse_power_results!\nget_raw_results\nget_raw_result\nget_results\nget_result\nadd_result!\nsave_updated_gen_table\nupdate_build_status!\nread_parsed_results\nread_processed_results","category":"page"},{"location":"results/overview/#E4ST.parse_results!","page":"Overview","title":"E4ST.parse_results!","text":"parse_results!(config, data, model) -> nothing\n\nGathers the values and shadow prices of each variable, expression, and constraint stored in the model and dumps them into data[:results][:raw] (see get_raw_results and get_results).  \nAdds relevant info to gen, bus, and branch tables.  See parse_lmp_results! and parse_power_results! for more information.\nSaves updated gen table via save_updated_gen_table\nSaves data to get_out_path(config,\"data_parsed.jls\") unless config[:save_data_parsed] is false (true by default).\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.process_results!","page":"Overview","title":"E4ST.process_results!","text":"process_results!(config::OrderedDict, data::OrderedDict) -> data\n\nCalls modify_results!(mod, config, data) for each Modification in config.  Stores the results into get_out_path(config, \"data_processed.jls\") if config[:save_data_processed] is true (default).\n\n\n\n\n\nprocess_results!(config; processed=true) -> data\n\nThis reads data in, then calls process_results!(config, data).  \n\nprocessed=false - reads in data via read_parsed_results\nprocessed=true - reads in data via read_processed_results\n\n\n\n\n\nprocess_results!(mod_file::String, out_path::String; processed=true) -> data\n\nProcesses the results the Modifications found in mod_file, a .yml file similar to a config file (see read_config), only requiring the mods field.\n\nprocessed=false - reads in data via read_parsed_results\nprocessed=true - reads in data via read_processed_results\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.parse_lmp_results!","page":"Overview","title":"E4ST.parse_lmp_results!","text":"parse_lmp_results!(config, data, res_raw)\n\nAdds the locational marginal prices of electricity and power flow.\n\ntable_name col_name unit description\n:bus :lmp_elserv DollarsPerMWhServed Locational Marginal Price of Energy Served\n:branch :lmp_pflow DollarsPerMWFlow Locational Marginal Price of Power Flow\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.parse_power_results!","page":"Overview","title":"E4ST.parse_power_results!","text":"parse_power_results!(config, data, res_raw)\n\nAdds power-based results.  See also get_table_summary for the below summaries.\n\ntable_name col_name unit description\n:bus :pgen MWGenerated Average Power Generated at this bus\n:bus :egen MWhGenerated Electricity Generated at this bus for the weighted representative hour\n:bus :pflow MWFlow Average power flowing out of this bus\n:bus :eflow MWhFlow Electricity flowing out of this bus\n:bus :pflow_in MWFlow Average power flowing into this bus\n:bus :eflow_in MWhFlow Electricity flowing out of this bus\n:bus :pflow_out MWFlow Average power flowing into this bus\n:bus :eflow_out MWhFlow Electricity flowing out of this bus\n:bus :plserv MWServed Average power served at this bus\n:bus :elserv MWhServed Electricity served at this bus for the weighted representative hour\n:bus :plcurt MWCurtailed Average power curtailed at this bus\n:bus :elcurt MWhCurtailed Electricity curtailed at this bus for the weighted representative hour\n:bus :elnom MWhLoad Electricity load at this bus for the weighted representative hour\n:gen :pgen MWGenerated Average power generated at this generator\n:gen :egen MWhGenerated Electricity generated at this generator for the weighted representative hour\n:gen :pcap MWCapacity Power generation capacity of this generator generated at this generator for the weighted representative hour\n:gen :ecap MWhCapacity Total energy generation capacity of this generator generated at this generator for the weighted representative hour\n:gen :pcap_retired MWCapacity Power generation capacity that was retired in each year\n:gen :pcap_built MWCapacity Power generation capacity that was built in each year\n:gen :pcapinvsim MWCapacity Total power generation capacity that was invested for the generator during the sim.  (single value).  Still the same even after retirement\n:gen :ecapinvsim MWhCapacity Total annual power generation energy capacity that was invested for the generator during the sim.  (pcapinvsim * hours per year) (single value).  Still the same even after retirement\n:gen :cf MWhGeneratedPerMWhCapacity Capacity Factor, or average power generation/power generation capacity, 0 when no generation\n:branch :pflow MWFlow Average Power flowing through branch\n:branch :eflow MWFlow Total energy flowing through branch for the representative hour\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.get_raw_results","page":"Overview","title":"E4ST.get_raw_results","text":"get_raw_results(data) -> raw::Dict{Symbol, Any}\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.get_raw_result","page":"Overview","title":"E4ST.get_raw_result","text":"get_raw_result(data, name) -> x\n\nRetrieves the raw result in data[:raw][name].  See also get_raw_results.\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.get_results","page":"Overview","title":"E4ST.get_results","text":"get_results(data) -> results::OrderedDict{Symbol, Any}\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.get_result","page":"Overview","title":"E4ST.get_result","text":"get_result(data, name) -> retult\n\nRetrieves data[:results][name].  See also add_result!\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.add_result!","page":"Overview","title":"E4ST.add_result!","text":"add_result!(data, name, result) -> nothing\n\nAdds result to data[:results].  See also get_result\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.save_updated_gen_table","page":"Overview","title":"E4ST.save_updated_gen_table","text":"save_updated_gen_table(config, data) -> nothing\n\nSave the gen table to get_out_path(config, \"gen.csv\")\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.update_build_status!","page":"Overview","title":"E4ST.update_build_status!","text":"update_build_status!(config, data, table_name)\n\nChange the build_status of generators built in the simulation.\n\nunbuilt -> new if last(pcap) is above threshold\nbuilt -> retired_exog if retired due to surpassing year_shutdown\nbuilt -> retired_endog if retired due before year_shutdown\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.read_parsed_results","page":"Overview","title":"E4ST.read_parsed_results","text":"read_parsed_results(config) -> data\n\nread_parsed_results(out_path) -> data\n\nLoads data in from get_out_path(config, \"data_parsed.jls\").\n\n\n\n\n\n","category":"function"},{"location":"results/overview/#E4ST.read_processed_results","page":"Overview","title":"E4ST.read_processed_results","text":"read_processed_results(config) -> data\n\nread_processed_results(out_path) -> data\n\nLoads data in from data_processed.jls.\n\n\n\n\n\n","category":"function"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"run_e4st","category":"page"},{"location":"overview/#E4ST.run_e4st","page":"Overview","title":"E4ST.run_e4st","text":"run_e4st(config) -> out_path, results\n\nrun_e4st(filename(s)) -> out_path, results\n\nTop-level function for running E4ST.  Here is a general overview of what happens:\n\nBook-keeping\nread_config(config_file) - loads in the config from file, if not passed in directly.  \nsave_config(config) - the config is saved to config[:out_path]\nstart_logging!(config) - Logging is started, some basic information is logged via log_start.\nLoad Input Data\nread_data(config) - The data is loaded in from files specified in the config.\nConstruct JuMP Model and optimize\nsetup_model(config, data) - The model (a JuMP Model) is set up.\nJuMP.optimize!(model) - The model is optimized.\nProcess Results\nparse_results!(config, data, model) - Retrieves all necessary values and shadow prices from model, storing them into data[:results][:raw], (see get_raw_results and get_results) and saves data if config[:save_data_parsed] is true (default is true).  This is mostly stored in case the results processing throws an error before completion.  That way, there is no need to re-run the model.\nprocess_results!(config, data) - Calls modify_results!(mod, config, data) for each mod in the config. Saves data if config[:save_data_processeded] is true (default is true)\nIterate, running more simulations as needed.\nSee Iterable and read_config for more information.\n\n\n\n\n\n","category":"function"},{"location":"#E4ST.jl","page":"Home","title":"E4ST.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the Julia rewrite of the Engineering, Economic, and Environmental Electricity Simulation Tool (E4ST), originally written in MATLAB, based on top of MATPOWER.  The idea for E4ST was developed in a joint effort at Cornell University and Resources for the Future by Daniel Shawhan and Ray Zimmerman, with major contributions from Biao Mao, Paul Picciano, Christoph Funke, Steven Whitkin, Ethan Russell, and Sally Robson.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the heart of E4ST is a detailed engineering representation of the power grid, and an optimization problem that represents the decisions of the system operators, electricity end-users, generators, and generation developers. The model represents these operation, consumption, investment, and retirement decisions by minimizing the sum of generator variable costs, fixed costs, investment costs, and end-user consumer surplus losses. E4ST provides detailed analysis to better inform policymakers, investors, and stakeholders. The power sector is increasingly complex, with challenging emission reduction aspirations, new energy technologies, an ever-changing policy backdrop, growing demand, and much uncertainty. Some of the challenges of representing the sector include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regional and national markets for clean electricity credits\nDiverse generation mixes with temporal variations\nMarkets for various fuel types and captured CO2\nIncreasing energy storage requirements","category":"page"},{"location":"","page":"Home","title":"Home","text":"To provide relevant analysis for such a complex and dynamic sector, models must to be fast to adapt and use. The previous version of E4ST was written as a wrapper for MATPOWER, a powerful Matlab-language package for solving steady-state power system simulation and optimization problems. However, as powerful as MATPOWER is, we desired the additional flexibility and speed that Julia can provide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"E4ST.jl was written with maximum flexibility and speed in mind. E4ST.jl is a bring-your-own-solver JuMP-based package. We leverage clever interfaces to inject custom modifications into the data loading, model setup, and results processing steps to allow for extreme configurability and extensibility. We allow for flexible time representations and time-varying inputs with space-and-time-efficient data retrieval.","category":"page"},{"location":"","page":"Home","title":"Home","text":"E4ST.jl uses the speed and extensibility of Julia to enable faster deployment of detailed and adaptable models to inform policy decision-makers and technology developers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warning As with most models, quality of analysis using E4ST.jl is heavily dependent on the inputs and assumptions.  For this reason, the E4ST team at RFF does not implicitly endorse all analysis done using E4ST.jl. If you have questions about the model inputs and assumptions used for our work at RFF, please contact us.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use E4ST.jl in your work, we request that you cite the following paper: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Shawhan2014,\n    author = {Daniel Shawhan, John T. Taber, Di Shi, Ray D. Zimmerman, Jubo Yan, Charles M. Marquet, Yingying Qi, Biao Mao, Richard E. Schuler, William Schulze, D.J. Tylavsky},\n    title = {{D}oes a {D}etailed {M}odel of the {E}lectricity {G}rid {M}atter? {E}stimating the {I}mpacts of the {R}egional {G}reenhouse {G}as {I}nitiative},\n    journal = {Resource and Energy Economics},\n    year = {2014},\n    doi = {10.1016/j.reseneeco.2013.11.015}}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can cite the following paper: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Shawhan2014,\n    author = {Daniel Shawhan, Paul D. Picciano},\n    title = {{C}osts and benefits of saving unprofitable generators: {A} simulation case study for {US} coal and nuclear power plants},\n    journal = {Energy Policy},\n    year = {2019},\n    doi = {https://doi.org/10.1016/j.enpol.2018.07.040}}","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Install-From-the-REPL-(preferred)","page":"Home","title":"Install From the REPL (preferred)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]\ndev git@github.com:e4st-dev/E4ST.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will clone E4ST into <path to julia depot (usually ~/.julia)>/dev/E4ST","category":"page"},{"location":"","page":"Home","title":"Home","text":"using E4ST","category":"page"},{"location":"#Install-via-Git-Bash","page":"Home","title":"Install via Git Bash","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the REPL installation doesn't work (due to git credentials or something) you can always install via Git Bash.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First navigate to the .julia/dev folder (make the dev folder if it's not already there).  Then run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.com:e4st-dev/E4ST.jl.git E4ST","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in a Julia REPL run (note that the bracket opens the package manager):","category":"page"},{"location":"","page":"Home","title":"Home","text":"]\ndev E4ST","category":"page"},{"location":"inputs/bus/#Bus-Table","page":"Bus Table","title":"Bus Table","text":"","category":"section"},{"location":"inputs/bus/","page":"Bus Table","title":"Bus Table","text":"setup_table!(config, data, ::Val{:bus})\nsummarize_table(::Val{:bus})","category":"page"},{"location":"inputs/bus/#E4ST.setup_table!-Tuple{Any, Any, Val{:bus}}","page":"Bus Table","title":"E4ST.setup_table!","text":"setup_table!(config, data, ::Val{:bus})\n\nSets up the bus table.  \n\nMakes a :bus_idx to track row numbers.\n\n\n\n\n\n","category":"method"},{"location":"inputs/bus/#E4ST.summarize_table-Tuple{Val{:bus}}","page":"Bus Table","title":"E4ST.summarize_table","text":"summarize_table(::Val{:bus})\n\ncolumn_name data_type unit required description\nref_bus Bool E4ST.NA true Whether or not the bus is a reference bus.  There should be a single reference bus for each island.\nreg_factor Float64 E4ST.NA true The percentage of generation that dispatches to a cost-of-service regulated market\n\n\n\n\n\n","category":"method"},{"location":"inputs/bus/#Additional-Columns:","page":"Bus Table","title":"Additional Columns:","text":"","category":"section"},{"location":"inputs/bus/","page":"Bus Table","title":"Bus Table","text":"Depending on what you are doing with the model, you may require additional fields associated with buses.  These could be things like:","category":"page"},{"location":"inputs/bus/","page":"Bus Table","title":"Bus Table","text":"latitude and longitude\nThe area that a bus is in such as state\nThe grid that the bus dispatches to","category":"page"},{"location":"types/mod/#Modifications","page":"Modication","title":"Modifications","text":"","category":"section"},{"location":"types/mod/","page":"Modication","title":"Modication","text":"Modification\nmodify_raw_data!(::Modification, config, data)\nmodify_setup_data!(::Modification, config, data)\nmodify_model!(::Modification, config, data, model)\nmodify_results!(::Modification, config, data)\nfieldnames_for_yaml(::Type{<:Modification})\nmod_rank(::Type{Modification})","category":"page"},{"location":"types/mod/#E4ST.Modification","page":"Modication","title":"E4ST.Modification","text":"abstract type Modification\n\nModification represents an abstract type for really anything that would make changes to a model.\n\nModifications represent ways to modify the behavior of E4ST.  Some possible examples of Modifications (not necessarily implemented) include:\n\nScale the NG price for each year\nEnforce a cap on carbon emissions in Colorado.\nAdding a national CES with changing target and benchmark rate\nPreventing the addition of new Nuclear Generation in PJM\nLogging a custom calculated result to file\nPlotting and saving a heat map of emissions by state as part of the results processing \nThe sky is the limit!\n\nDefining a Modification\n\nWhen defining a concrete Modification type, you should know the following.\n\nSince Modifications are specified in a YAML config file, Modifications must be constructed with keyword arguments.  Base.@kwdef may come in handy here.\nAll Modications are paired with a name in the config file.  That name is automatically passed in as a keyword argument to the Modification constructor if the type has a name field.  The name will be passed in as a Symbol.\n\nModification's can modify things in up to four places, with the default behavior of the methods being to make no changes:\n\nmodify_raw_data!(mod, config, data) - In the data preparation step, right after read_data_files!(config, data) before setting up the data\nmodify_setup_data!(mod, config, data) - In the data preparation step, right after setup_data!(config, data) before setting up the Model\nmodify_model!(mod, config, data, model) - In the model setup step, after setting up the DC-OPF but before optimizing\nmodify_results!(mod, config, data) - After optimizing the model, in the results generation step\n\nModifications get printed to YAML when the config file is saved at the beginning of a call to run_e4st.  If you implement a Modification for which it is undesirable to print every field, you can implement the following interface:\n\nfieldnames_for_yaml(::Type) - returns the desired fieldnames as a collection of Symbols\n\nModification can be given a rank which will determine the order that they are called in when modifying the model. This can be important if a mod requires information calculated in a previous mod or needs to be applied on top of another mod.  Ranks is specified by defining a method for mod_rank(::Type{<:Modification}). The default rank is 0. Modifications that setup data and model features like CCUS and DCLines can have negative values to signify that they are called before while mods like policies would have a positive rank meaning they would modify the model after the setup mods. \n\nSpecifying a Modification in the config file YAML\n\nModifications must be be specified in the config file.  They must have a type key, and keys for each other desired keyword argument in the constructor.\n\nAn Example\n\nSay we want to make a Modification to change the price of natural gas based on a table in a CSV file.\n\nusing E4ST, CSV, DataFrames\nstruct UpdateNGPrice <: Modification\n    filename::String\n    prices::DataFrame\nend\n\n# Define kwarg constructor\nfunction UpdateNGPrice(; filename=nothing)\n    filename === nothing && error(\"Must provide UpdateNGPrice with a filename\")\n    prices = CSV.read(filename, DataFrame)\n    return UpdateNGPrice(filename, prices)\nend\n\n# Make sure YAML doesn't try printing out the whole prices table\nfunction E4ST.fieldnames_for_yaml(::Type{UpdateNGPrice})\n    return (:filename,)\nend\n\nfunction E4ST.modify_raw_data!(mod::UpdateNGPrice, config, data)\n    # update the price of natural gas from mod.prices here\nend\n\nNow, to add this to the mods list in the config file:\n\nmods:\n  ...                                   # other mods as needed\n  update_ng_price:                      # This is the name of the mod\n    type: UpdateNGPrice\n    filename: \"C:/path/to/file.csv\"\n  ...                                   # other mods as needed\n\n\n\n\n\n","category":"type"},{"location":"types/mod/#E4ST.modify_raw_data!-Tuple{Modification, Any, Any}","page":"Modication","title":"E4ST.modify_raw_data!","text":"modify_raw_data!(mod::Modification, config, data, model)\n\nChange the raw data with mod.\n\n\n\n\n\n","category":"method"},{"location":"types/mod/#E4ST.modify_setup_data!-Tuple{Modification, Any, Any}","page":"Modication","title":"E4ST.modify_setup_data!","text":"modify_setup_data!(mod::Modification, config, data, model)\n\nChange the setup data with mod.\n\n\n\n\n\n","category":"method"},{"location":"types/mod/#E4ST.modify_model!-Tuple{Modification, Any, Any, Any}","page":"Modication","title":"E4ST.modify_model!","text":"modify_model!(mod::Modification, config, data, model)\n\nApply mod to the model, called in setup_model\n\n\n\n\n\n","category":"method"},{"location":"types/mod/#E4ST.modify_results!-Tuple{Modification, Any, Any}","page":"Modication","title":"E4ST.modify_results!","text":"modify_results!(mod::Modification, config, data)\n\nGather the results from mod from the solved model, called in parse_results!\n\n\n\n\n\n","category":"method"},{"location":"types/mod/#E4ST.fieldnames_for_yaml-Tuple{Type{<:Modification}}","page":"Modication","title":"E4ST.fieldnames_for_yaml","text":"fieldnames_for_yaml(::Type{M}) where {M<:Modification}\n\nreturns the fieldnames in a yaml, used for printing, modified for different types of mods \n\n\n\n\n\n","category":"method"},{"location":"types/mod/#E4ST.mod_rank-Tuple{Type{Modification}}","page":"Modication","title":"E4ST.mod_rank","text":"mod_rank(::Type{Modification}) ->\n\nReturns the rank of the Modification.  Rank is the order in which the type of mod should be applied relative to other types of mods.  Defaults to 0, where 1 would come after other mods and -1 would come before.  Ranks is defined for mod types. \n\n\n\n\n\n","category":"method"}]
}
